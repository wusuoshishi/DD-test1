C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE XS16TK06X_TK
OBJECT MODULE PLACED IN .\Output\XS16TK06X_TK.obj
COMPILER INVOKED BY: D:\Program_Files\KEIL5_521A\C51\BIN\C51.EXE Source\XS16TK06X_TK.c OMF2 OPTIMIZE(8,SPEED) BROWSE INC
                    -DIR(.\Inc;.\User;.\Application_Library;.\Project) DEBUG PRINT(.\List\XS16TK06X_TK.lst) OBJECT(.\Output\XS16TK06X_TK.obj)

line level    source

   1          #include "Config.h"
   2          #if (CS_SW == 1)
                      #include "DataDeal.h"
              #endif
   5          
   6          
   7          #if SNS_NUM
   8          
   9          unsigned char code      SNS[26] ={SCAN_00,SCAN_01,SCAN_02,SCAN_03,SCAN_04,SCAN_05,SCAN_06,SCAN_07,SCAN_08,SCAN
             -_09,SCAN_10,SCAN_11,SCAN_12,SCAN_13,SCAN_14,SCAN_15,SCAN_16,SCAN_17,SCAN_18,SCAN_19,SCAN_20,SCAN_21,SCAN_22,SCAN_23,SCAN
             -_24,SCAN_25};
  10          unsigned int    code  FTH[26]   ={FTH00,FTH01,FTH02,FTH03,FTH04,FTH05,FTH06,FTH07,FTH08,FTH09,FTH10,FTH11,FTH1
             -2,FTH13,FTH14,FTH15,FTH16,FTH17,FTH18,FTH19,FTH20,FTH21,FTH22,FTH23,FTH24,FTH25};
  11          unsigned int    code    PUIV[26]={PUIV00,PUIV01,PUIV02,PUIV03,PUIV04,PUIV05,PUIV06,PUIV07,PUIV08,PUIV09,PUIV10
             -,PUIV11,PUIV12,PUIV13,PUIV14,PUIV15,PUIV16,PUIV17,PUIV18,PUIV19,PUIV20,PUIV21,PUIV22,PUIV23,PUIV24,PUIV25};
  12          
  13          unsigned char xdata pull_i_step[SNS_NUM]        = {7};
  14          unsigned int    xdata pull_i_value[SNS_NUM] = {300};
  15          unsigned char xdata sensor_open[SNS_NUM]        = {0};
  16          unsigned char xdata sns_next_count = 0;
  17          
  18          
  19          
  20          //-----------------------------------------------------------------//
  21          //函数名称： void CTK_Set_Para(void)
  22          //函数功能： 设置CTK扫描参数及基线更新参数
  23          //输入参数： 无
  24          //输出参数： 无
  25          //返 回 值： 无
  26          //-----------------------------------------------------------------//
  27          void CTK_Set_Para(void)
  28          {
  29   1      
  30   1                      unsigned char i = 0;
  31   1                      for (i = 0; i < SNS_NUM; i++)
  32   1                      {
  33   2                              open_sns |= ((ulong)0x01)<<SNS[i];
  34   2                              sensor_open[i] = SNS[i];
  35   2                              pull_i_value[i] = PUIV[i];
  36   2                              //初始化电流源参数
  37   2                              raw_data[i] = 0;
  38   2                              n_base_line[i] = base_line[i] = 0x0001;
  39   2                              
  40   2                      }
  41   1              
  42   1      }
  43          
  44          uchar Sns_Count = 0;
  45          unsigned char xdata i;
  46          unsigned char xdata touch_confirm_count[SNS_NUM] = {0};
  47          unsigned char xdata touch_left_count[SNS_NUM] = {0};
  48          
  49          unsigned char xdata over_p_noise_count[SNS_NUM] = {0};
  50          unsigned char xdata under_p_noise_count[SNS_NUM] = {0};
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 2   

  51          unsigned char xdata over_n_noise_count[SNS_NUM] =  {0};
  52          unsigned char xdata under_n_noise_count[SNS_NUM] = {0};
  53          unsigned char xdata under_nn_noise_count[SNS_NUM] = {0};
  54          unsigned char xdata n_base_line_reno_count[SNS_NUM] = {0};
  55          
  56          #if UN_NORMAL_CHECK
                              unsigned char xdata un_normal_count = 0;
                              unsigned char xdata un_normal_recover_count = 0;
                              bit un_normal_flag = 0;
                              unsigned long xdata adjust_flag = 0;
              
              
              //-----------------------------------------------------------------//
              //函数名称： void Rawdata_Un_Normal(uchar sns_num)
              //函数功能： Rawdata异常判断，注：不能识别所有异常情况，此功能根据实际项目情况添加。
              //输入参数： uchar sns_num：通道索引
              //输出参数： 无
              //返 回 值： 无
              //-----------------------------------------------------------------//
              void Rawdata_Un_Normal(uchar sns_num)
              {
                      if(un_normal_flag == 0)
                      {
                                      if(raw_data[sns_num] >= (((unsigned long)(((unsigned long)0x0001)<<(((SNS_SCAN_CFG3>>4)&0x07) + 9)))*8/
             -10))        
                                      {
                                                      
                                                      un_normal_count++;
                                                      if(un_normal_count >= UN_NORMAL_MAX_COUNT)
                                                      {
                                                                      un_normal_count = 0;
                                                                      if(un_normal_recover_count < UN_NORMAL_RECOVER_MAX_COUNT)//允许异常判断恢复un_normal_recover_max_co
             -unt次
                                                                      {
              
                                                                                      EA = 0;                                                                                 //关总中断
                                                                                      adjust_done_flag = 0;
                                                                                      un_normal_recover_count++;
                                                                                      CTK_IE_SET;
                                                                                      CTK_ADDR_SET(sensor_open[0]);
                                                                                      CTK_START;
                                                                                      EA = 1;                                                                                 //开总中断
              
                                                                      }
                                                      }
                                      }
                              
                      }       
              
              }
              #endif
 100          
 101          //-----------------------------------------------------------------//
 102          //函数名称： void CTK_Init(void)
 103          //函数功能： CTK初始化
 104          //输入参数： 无
 105          //返 回 值： 无
 106          //-----------------------------------------------------------------//
 107          
 108          void CTK_Init(void)
 109          {
 110   1              EA = 0;                                                                                 //关总中断
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 3   

 111   1              //设置CTK扫描参数及基线更新参数
 112   1              CTK_Set_Para();
 113   1              
 114   1              CTK_IE_SET;
 115   1              CTK_IP_CLR;
 116   1              
 117   1              TRISB |= ((open_sns >> 0)  & 0xFF);
 118   1              TRISC |= ((open_sns >> 8)  & 0xFF);
 119   1              TRISD |= ((open_sns >> 16) & 0xFF);
 120   1              TRISA |= ((open_sns >> 24) & 0x03);
 121   1      
 122   1              SNS_IO_SEL1 |= ((open_sns)&0xFF);
 123   1              SNS_IO_SEL2 |= ((open_sns>>8)&0xFF);
 124   1              SNS_IO_SEL3 |= ((open_sns>>16)&0xFF);
 125   1              SNS_IO_SEL4 |= ((open_sns>>24)&0x03);//SNS、IO选择
 126   1              
 127   1              CTK_PRS_SW_SET(0);                                      //前端充放电开关,1为关，0为开
 128   1              CTK_RESO_SET(CTK_RESO);         //0~7 CTK电容扫描分辨率，计数器位数：(CFG_CTK_RESOLUTION+9)位。
 129   1              CTK_PRS_SET(CTK_PRS);                   //PRS(充放电频率) = 48/2/(x+4),62:正态分布(1~1.5~3)MHz,63:均匀分布(1~1.5~3)MHz,2
             -6--800KHz,20--1MHz,12--1.5MHz,8--2MHz
 130   1              CTK_DS_SET(CTK_DS);                             //检测速度0:24MHz,1:12MHz,2:6MHz,3:4MHz
 131   1              CTK_PAR_SET(Mode);                                      //0为单通道模式，1为多通道并联模式
 132   1              CTK_RB_SET(CTK_RB);                                     //选择RB电阻大小4:60K 5:80K 其它保留
 133   1              CTK_VTH_SET(CTK_REF);                           //参考电压(0:1.5V),(1:2.1V),(2:2.5V),(3:2.9V),(4:3.2V),(5:3.5V),(6:3.9V),(7:4.2V
             -);注：VCC-VTH>0.5V
 134   1              CTK_PULL_I_SET(pull_i_value[0]);//设置电流源级数
 135   1              CTK_PRE_CH_SET(1);                                      //预充电时间：0为20us,1为40us
 136   1              CTK_PRE_DISCH_SET(1);                           //预放电时间：0为2us,1为10us
 137   1      
 138   1              CTK_PD_SET(0);                                                  //0为CTK开，1为CTK关
 139   1              CTK_STOP;                                                                               //停止扫描
 140   1      
 141   1              CTK_ADDR_SET(sensor_open[0]);
 142   1              
 143   1              CTK_START;
 144   1              EA = 1;                                                                                 //开总中断
 145   1              
 146   1      }
 147          #endif
 148          //-----------------------------------------------------------------//
 149          //函数名称： void XS16TK06X_Set_Touch_Flag(void)
 150          //函数功能： 触摸判断并置位或者清除触摸标志位
 151          //输入参数： 无
 152          //输出参数： 无
 153          //返 回 值： 无
 154          //-----------------------------------------------------------------//
 155          void XS16TK06X_Set_Touch_Flag(void)
 156          {
 157   1              #if SNS_NUM     
 158   1                      #ifdef IDLE_MODE
 159   1                              #if (IDLE_MODE == 1)
                                      if(parallel_mode == 0)
                                      {
                                              if(ctk_circle_done == 1)//中断模式
                                              {
                                                      ctk_circle_done = 0;
                                                      CTK_IE_CLR;//关CTK中断
                                              
                                                      for(Sns_Count = 0; Sns_Count < SNS_NUM; Sns_Count++)
                                                      {
                                                              if(SNS[Sns_Count] != 255)
                                                              {
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 4   

                                                                      
                                                                      CTK_SNS_Renovate(Sns_Count,((ulong)FTH[Sns_Count]*((ulong)CFG_Rb*1000/CTK_RB_ADJ))/1000);
                                                                      
                                                                      #if TRACEMODE
                                                                      
                                                                              if(keys_flag & ((long)0x01 << SNS[Sns_Count]))
                                                                              {
                                                                                      keys_flag_Tracemode |= ((long)0x01 << Sns_Count);
                                                                              }
                                                                              else
                                                                              {
                                                                                      keys_flag_Tracemode &= ~((long)0x01 << Sns_Count);
                                                                              }
                                                                      
                                                                      #endif
                                                                      
                                                                      #if UN_NORMAL_CHECK
                                                                              Rawdata_Un_Normal(Sns_Count);
                                                                      #endif
                                                              }
                                                              
                                                      }
                                                      CTK_IE_SET;//开CTK中断
                                              }
                                      }
                                      else
                                      {
                                                      Idle(); 
                                      }
                                      #else
 201   1                                              if(ctk_circle_done == 1)//中断模式
 202   1                                              {
 203   2                                                      ctk_circle_done = 0;
 204   2                                                      CTK_IE_CLR;//关CTK中断
 205   2      
 206   2                                                      for(Sns_Count = 0; Sns_Count < SNS_NUM; Sns_Count++)
 207   2                                                      {
 208   3                                                              if(SNS[Sns_Count] != 255)
 209   3                                                              {
 210   4                                                                      
 211   4                                                                      CTK_SNS_Renovate(Sns_Count,((ulong)FTH[Sns_Count]*((ulong)CFG_Rb*1000/CTK_RB_ADJ))/1000);
 212   4                                                              
 213   4                                                                      #if TRACEMODE
                                                                                      if(keys_flag & ((long)0x01 << SNS[Sns_Count]))
                                                                                      {
                                                                                              keys_flag_Tracemode |= ((long)0x01 << Sns_Count);
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                              keys_flag_Tracemode &= ~((long)0x01 << Sns_Count);
                                                                                      }
                                                                              #endif
 223   4                                                                      
 224   4                                                                      #if UN_NORMAL_CHECK
                                                                                      Rawdata_Un_Normal(Sns_Count);
                                                                              #endif
 227   4                                                              }
 228   3                                                              
 229   3                                                      }
 230   2                                                      CTK_IE_SET;//开CTK中断
 231   2                                              }
 232   1                              #endif
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 5   

 233   1                      #endif
 234   1                      
 235   1                      #ifndef IDLE_MODE
                              if(ctk_circle_done == 1)//中断模式
                              {
                                      ctk_circle_done = 0;
                                      CTK_IE_CLR;//关CTK中断
              
                                      for(Sns_Count = 0; Sns_Count < SNS_NUM; Sns_Count++)
                                      {
                                              if(SNS[Sns_Count] != 255)
                                              {
                                                      
                                                      CTK_SNS_Renovate(Sns_Count,((ulong)FTH[Sns_Count]*((ulong)CFG_Rb*1000/CTK_RB_ADJ))/1000);
                                              
                                                      #if TRACEMODE
                                                              if(keys_flag & ((long)0x01 << SNS[Sns_Count]))
                                                              {
                                                                      keys_flag_Tracemode |= ((long)0x01 << Sns_Count);
                                                              }
                                                              else
                                                              {
                                                                      keys_flag_Tracemode &= ~((long)0x01 << Sns_Count);
                                                              }
                                                      #endif
                                                      
                                                      #if UN_NORMAL_CHECK
                                                              Rawdata_Un_Normal(Sns_Count);
                                                      #endif
                                              }
                                              
                                      }
                                      CTK_IE_SET;//开CTK中断
                              }
                              #endif
 268   1              #endif
 269   1              
 270   1              #ifdef SLEEP_MODE
 271   1                      #if (SLEEP_MODE == 1)
                                      Sleep();
                              #endif
 274   1              #endif  
 275   1      }       
 276          
 277          //////////TK////////////
 278          
 279          #if CH_MAX
 280          unsigned int  xdata raw_data[CH_MAX] ={0};
 281          unsigned int  xdata base_line[CH_MAX] = {1};
 282          #endif
 283          
 284          #if SNS_NUM
 285                  unsigned char xdata Mode = 0;
 286                  unsigned char sns_next = 0;
 287                  static unsigned char xdata adjust_count = 0;
 288          
 289                  #if (CS_SW == 1)
                              uint cs_noise = 0;
                      #endif
 292          
 293                  bit adjust_done_flag = 0;
 294                  bit base_line_int_flag = 0;
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 6   

 295                  bit ctk_circle_done = 0;
 296                  
 297          
 298                  unsigned int xdata pull_i_value_parallel = 100;
 299                  unsigned long xdata open_sns = 0;
 300                  unsigned long xdata open_sns_tem = 0;
 301                  bit parallel_mode = 0;
 302                  bit parallel_init_flag = 1;
 303                  bit ctk_para_done = 0;
 304                  
 305          
 306                  unsigned int  xdata n_base_line[SNS_NUM] = {1};
 307          
 308                  unsigned long xdata muli_key_flag = 0;
 309                  unsigned long xdata keys_flag = 0;      
 310                  unsigned long xdata mode_flag = 0;
 311                          
 312                  unsigned int  xdata long_key_clear_count = 0;           
 313          
 314                  unsigned char xdata multi_key_count = 0;
 315                  unsigned char xdata multi_key_reset_cnt = 0;
 316          
 317                  #if (RENOVATE_MODE == 1)
                      bit water_flow_flag = 0;        
                      unsigned int    xdata water_flow_left_count = 0;        
                      unsigned char xdata water_flow_key_count = 0;   
                      unsigned char xdata water_flow_key_reset_cnt = 0;
                      #endif
 323                  
 324                  void CTK_XS16TK06X_Adjust_Int(void);
 325                  void CTK_XS16TK06X_Para_Adjust_Int(void);
 326                  void Base_Line_Init();
 327                  void Set_Next_SNS(void);
 328                  
 329                  #ifdef IDLE_MODE
 330                          #if IDLE_MODE
                              
                              //-----------------------------------------------------------------//
                              //函数名称： void Set_Para_SNS(void)
                              //函数功能： 设置并联模式通道
                              //输入参数： 无
                              //输出参数： 无
                              //返 回 值： 无
                              //-----------------------------------------------------------------//   
                              void Set_Para_SNS(void)
                              {
                                              CTK_PAR_SET(1);                                         //0为单通道模式，1为多通道并联模式
                                              CTK_PULL_I_SET(pull_i_value_parallel);//设置级数
                                              CTK_RESO_SET(CTK_PARA_RESO); 
                                              CTK_PRS_SET(CTK_PARA_PRS);
                                              CTK_RB_SET(CTK_PARA_RB);        
                                              CTK_VTH_SET(CTK_PARA_REF);      
                                              CTK_ADDR_SET(sensor_open[0]);
                                              CTK_START;
                              }
                              
                              //-----------------------------------------------------------------//
                              //函数名称： void CTK_XS16TK06X_Para_Adjust_Int(void)
                              //函数功能：并联模式通道电流源自适应
                              //输入参数： 无
                              //输出参数： 无
                              //返 回 值： 无
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 7   

                              //-----------------------------------------------------------------//        
              
                              void CTK_XS16TK06X_Para_Adjust_Int(void)
                              {
                                      if(adjust_count < 3)
                                      {
                                              while(1)
                                              {
                                                      WDT_CTRL = 7;
                                                      
                                                      if((raw_data_parallel[0] >= ADJUST_PARA_LINE))
                                                      {
                                                              if(pull_i_value_parallel < (511 - ADJUST_STE))
                                                              {
                                                                      pull_i_value_parallel += (1 + ADJUST_STE);
                                                                      
                                                                      
                                                                      Set_Para_SNS();
                                                                      return;
                                                              }       
                                                              else
                                                              {
                                                                      parallel_init_flag = 1;
                                                                      base_line_parallel[0] = raw_data_parallel[0];                                           
                                                                      Set_Next_SNS();
                                                                      return;
                                                              }
                                                      }
                                                      else
                                                      {       
                                                                      if(adjust_count < 3)
                                                                      {
                                                                              adjust_count++;
                                                                      }
              
                                                                      if(pull_i_value_parallel > (0))
                                                                      {
                                                                              pull_i_value_parallel-= (1);
                                                                              
                                                                              Set_Para_SNS();
                                                                              
                                                                              return;
                                                                      }
                                                                      else
                                                                      {
                                                                                      Set_Para_SNS();
                                                                                      return;
                                                                      }       
                                                      }
                                              }
                                      }
                                      
                                      if(adjust_count >= 3)
                                      {
                                              while(1)
                                              {
                                                      WDT_CTRL = 7;
                                                      
                                                      if((raw_data_parallel[0] <= ADJUST_PARA_LINE))
                                                      {
                                                              if(pull_i_value_parallel > (0))
                                                              {
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 8   

                                                                      pull_i_value_parallel -= (1);
                                                              
                                                                      Set_Para_SNS();
                                                                      return;
                                                              }       
                                                              else
                                                              {
                                                                      parallel_init_flag = 1;
                                                                      base_line_parallel[0] = raw_data_parallel[0];
                                                                      Set_Next_SNS();
                                                                      return;
                                                              }
                                                      }
                                                      else
                                                      {       
                                                                      if(adjust_count < 6)
                                                                      {
                                                                              adjust_count++;
                                                                      }
                                                                      if(adjust_count >= 6)
                                                                      {
                                                                              adjust_count = 0;
                                                                              parallel_init_flag = 1;
                                                                              base_line_parallel[0] = raw_data_parallel[0];                                           
                                                                              Set_Next_SNS();
                                                                              return;
                                                                      }
              
                                                                      if(pull_i_value_parallel < (511 - ADJUST_STE))
                                                                      {
                                                                              pull_i_value_parallel += (1 + ADJUST_STE);
              
                                                                              Set_Para_SNS();
                                                                              return;
                                                                      }
                                                                      else
                                                                      {
                                                                                      Set_Para_SNS();
                                                                                      return;
                                                                      }       
                                                      }
                                              }
                                      }
                              }
                              #endif
 464                  #endif
 465                  //-----------------------------------------------------------------//
 466                  //函数名称： void Set_Next_SNS(void)
 467                  //函数功能： 设置下一个通道
 468                  //输入参数： 无
 469                  //输出参数： 无
 470                  //返 回 值： 无
 471                  //-----------------------------------------------------------------//   
 472                  void Set_Next_SNS(void)
 473                  {
 474   1      
 475   1                      CTK_PULL_I_SET(pull_i_value[sns_next]);//设置电流源级数
 476   1                      CTK_ADDR_SET(sensor_open[sns_next]);
 477   1                      
 478   1                      #ifdef IDLE_MODE
 479   1                              #if IDLE_MODE
                                              CTK_PAR_SET(0);                                         //0为单通道模式，1为多通道并联模式
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 9   

                                              CTK_RESO_SET(CTK_RESO); 
                                              CTK_PRS_SET(CTK_PRS); 
                                              CTK_VTH_SET(CTK_REF);   
                                              CTK_RB_SET(CTK_RB);     
                                      #endif
 486   1                      #endif
 487   1      
 488   1                      CTK_START;
 489   1              }
 490                  
 491                  //-----------------------------------------------------------------//
 492                  //函数名称： void CTK_ISR() interrupt 12
 493                  //函数功能： CTK中断服务函数
 494                  //输入参数： 无
 495                  //输出参数： 无
 496                  //返 回 值： 无
 497                  //-----------------------------------------------------------------//   
 498                  void CTK_ISR() interrupt 12
 499                  {
 500   1                      
 501   1                              CTK_INT_FLAG_CLR;//清除CTK中断标志位
 502   1      
 503   1                              CTK_STOP;       
 504   1                      
 505   1                              #ifdef Timer0_EN
 506   1                                      #if Timer0_EN
 507   1                                              ctk_soft_reset_count = 0;
 508   1                                      #endif
 509   1                              #endif
 510   1                      
 511   1                              if(parallel_mode == 0)
 512   1                              {
 513   2                                              #if (CS_SW == 1)
                                                      if(adjust_done_flag == 0)
                                                      #endif
 516   2                                              {                                                       
 517   3                                                              EA = 0;
 518   3                                                              raw_data[sns_next] = ((unsigned int)CSD_RAWDATAH << 8) | (unsigned int)CSD_RAWDATAL;//获取CTK数据
 519   3                                                              EA = 1;                                                 
 520   3                                              }
 521   2                                              
 522   2                                              if(adjust_done_flag == 0)
 523   2                                              {
 524   3                                                      #ifdef IDLE_MODE
 525   3                                                              #if IDLE_MODE
                                                                              parallel_init_flag = 0;
                                                                      #endif
 528   3                                                      #endif
 529   3                                                      CTK_XS16TK06X_Adjust_Int();
 530   3                                                      
 531   3                                              }
 532   2                                              else
 533   2                                              {
 534   3                                                              if(parallel_init_flag == 1)
 535   3                                                              {
 536   4      
 537   4                                                                      #if (CS_SW == 1)        
                                                                                      cs_noise = Data_Deal(CS_F_NUM,0,SNS_NUM); 
                                                                                      Set_Next_SNS();
                                                                              #else
 541   4                                                                      
 542   4                                                                      
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 10  

 543   4                                                                      sns_next++;
 544   4                                                                      while(sensor_open[sns_next] == 0xFF)
 545   4                                                                      {
 546   5                                                                                      CTK_STOP;       
 547   5                                                                                      sns_next++;
 548   5                                                                                      if(sns_next >= SNS_NUM)
 549   5                                                                                      {
 550   6                                                                                                      sns_next = 0;
 551   6                                                                                                      ctk_circle_done = 1;
 552   6                                                                                                      break;
 553   6                                                                                      }
 554   5                                                                      }
 555   4                                                                      if(sns_next >= SNS_NUM)
 556   4                                                                      {
 557   5                                                                                      sns_next = 0;
 558   5                                                                                      
 559   5                                                                                      ctk_circle_done = 1;
 560   5                                                                      }
 561   4                                                                      
 562   4                                                                      Set_Next_SNS();
 563   4                                                                      #endif
 564   4                                                              }
 565   3                                                              #ifdef IDLE_MODE
 566   3                                                                      #if IDLE_MODE
                                                                              else
                                                                              {
                                                                                                      EA = 0;
                                                                                                      raw_data_parallel[0] = ((unsigned int)CSD_RAWDATAH << 8) | (unsigned int)CSD_RAWDATAL;//获取CTK
             -数据
                                                                                                      EA = 1;
                                                                                                      
                                                                                                      CTK_XS16TK06X_Para_Adjust_Int();
                                                                              }
                                                                              #endif
 576   3                                                              #endif
 577   3                                              }
 578   2                              }
 579   1                              #ifdef IDLE_MODE
 580   1                                      #if IDLE_MODE
                                              else
                                              {
                                                              EA = 0;
                                                              raw_data_parallel[0] = ((unsigned int)CSD_RAWDATAH << 8) | (unsigned int)CSD_RAWDATAL;//获取CTK数据
                                                              EA = 1;
                                                      
                                                              ctk_para_done = 1;
                                                              Set_Para_SNS();
                                                              
                                              }
                                              #endif
 592   1                              #endif
 593   1              }
 594          
 595                  //-----------------------------------------------------------------//
 596                  //函数名称： void Base_Line_Init()
 597                  //函数功能： 基线初始化
 598                  //输入参数： 无
 599                  //输出参数： 无
 600                  //返 回 值： 无
 601                  //-----------------------------------------------------------------//
 602                  void Base_Line_Init()
 603                  {   
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 11  

 604   1                              unsigned char xdata i;
 605   1                              for (i = 0; i < SNS_NUM; i++) 
 606   1                              {
 607   2                                      #if KEYS_RENOVATE_FLAG
 608   2                                      if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[i]))
 609   2                                      {
 610   3                                              EA = 0;
 611   3                                              base_line[i] = raw_data[i];
 612   3                                              EA = 1;
 613   3                                      }
 614   2                                      #endif
 615   2                              }       
 616   1              }
 617          
 618          
 619          
 620                  //-----------------------------------------------------------------//
 621                  //函数名称： void CTK_Long_TK_Count(void)
 622                  //函数功能： 长按键计数
 623                  //输入参数： 无
 624                  //输出参数： 无
 625                  //返 回 值： 无
 626                  //-----------------------------------------------------------------//
 627                  void CTK_Long_TK_Count(void)
 628                  {
 629   1                                      #if LONG_KEY_COUNT
 630   1                                      if(long_key_clear_count >= LONG_KEY_COUNT)
 631   1                                      {
 632   2                                                      long_key_clear_count = 0;
 633   2                                                      keys_flag = 0;
 634   2                                                      Base_Line_Init();
 635   2                                      }
 636   1                                      #endif
 637   1              }
 638          
 639          
 640                  //-----------------------------------------------------------------//
 641                  //函数名称： void CTK_TK_Left_Count(uchar addr)
 642                  //函数功能： 手指离开判断计数
 643                  //输入参数： addr：通道号
 644                  //输出参数： 无
 645                  //返 回 值： 无
 646                  //-----------------------------------------------------------------//
 647                  void CTK_TK_Left_Count(uchar addr)
 648                  {
 649   1                              touch_left_count[addr]++;
 650   1                              touch_confirm_count[addr] = 0;
 651   1                              if(touch_left_count[addr] >= TK_LEFT_COUNT)
 652   1                              {
 653   2                                      touch_left_count[addr] = 0;
 654   2                                      keys_flag &= ~(((unsigned long)0x01) << sensor_open[addr]);
 655   2                              }
 656   1              }
 657          
 658                  //-----------------------------------------------------------------//
 659                  //函数名称： void CTK_SNS_Renovate(unsigned char addr,unsigned int fth)
 660                  //函数功能： SNS基线更新
 661                  //输入参数： unsigned char addr：SNS通道;unsigned int fth:手指阈值
 662                  //输出参数： 无
 663                  //返 回 值： 无
 664                  //-----------------------------------------------------------------//
 665                  void CTK_SNS_Renovate(unsigned char addr,unsigned int fth)
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 12  

 666                  {
 667   1                      long differ = 0;
 668   1                      
 669   1                      #if (RENOVATE_MODE == 1)
                                      long differ_mode1 = 0;
                              #endif
 672   1                      #if (MULTI_KEY_MAX_COUNT != 0)
                              unsigned char i = 0;
                              #endif
 675   1                      long fth_tem = 0;
 676   1                      fth_tem = fth;
 677   1                      
 678   1                      differ = (long)base_line[addr] - (long)raw_data[addr];
 679   1      
 680   1                      
 681   1                      #if (CS_SW == 1)
                                      if(cs_noise >= CS_NOISE)
                                      {
                                              fth_tem = (CS_FTH_RATE*fth_tem)/10;
                                      }
                                      if((keys_flag & ((ulong)0x01 << sensor_open[addr])))
                                      {
                                              fth_tem = (FTHD_HY_RATE*fth_tem)/10;
                                      }
              
                              #endif
 692   1                              
 693   1                      
 694   1                      
 695   1                      if((keys_flag & ((ulong)0x01 << sensor_open[addr])))
 696   1                      {
 697   2                              fth_tem = (TK_RATE_HY*fth_tem)/10;
 698   2                      }
 699   1                              
 700   1                      if(adjust_done_flag == 1)
 701   1                      {
 702   2                              if(base_line_int_flag == 0)
 703   2                              {
 704   3                                      base_line_int_flag = 1;
 705   3                              
 706   3                                      Base_Line_Init();
 707   3                                      
 708   3                              }
 709   2                      }
 710   1                      
 711   1                      CTK_Long_TK_Count();
 712   1                      
 713   1                      #if TK_EOT
                                      if(differ >= 0)
                                      {
                                              if(differ >= (fth_tem*TK_EOT))
                                              {
                                                              touch_left_count[addr] = 0;
                                                              touch_confirm_count[addr] = 0;
                                                              keys_flag &= ~(((unsigned long)0x01) << sensor_open[addr]);
                                                              Base_Line_Init();
                                              }
                                      }
                              #endif
 725   1                      
 726   1                      #if (MULTI_KEY_MAX_COUNT != 0)
                              if(differ >= 0)
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 13  

                              {
                                      if(differ >= (((int)fth)*RENOVATE_NTH_RATE/10))//多按键标志判断
                                      {
                                                      muli_key_flag |= ((long)0x01 << sensor_open[addr]);     
                                      }
                                      else
                                      {
                                                      muli_key_flag &= ~((long)0x01 << sensor_open[addr]);    
                                      }
                              }
                              else
                              {
                                              muli_key_flag &= ~((long)0x01 << sensor_open[addr]);    
                              }
                              
                              multi_key_count = 0;
                              for(i = 0; i < SNS_NUM;i++)//模式1多按键判断
                              {
                                      if((muli_key_flag & (((unsigned long)0x01) << sensor_open[i])))
                                      {
                                              multi_key_count++;//模式1多按键计数
                                      }
                              }
              
                              if(multi_key_count > MULTI_KEY_MAX_COUNT)
                              {
                                              multi_key_count = 0;
                                              multi_key_reset_cnt++;
                                              if(multi_key_reset_cnt >= MULTI_KEY_RST_COUNT)
                                              {
                                                      multi_key_reset_cnt = 0;
                                                      
                                                      keys_flag= 0;
                                                      Base_Line_Init();
                                              
                                              }
                              }
                              else
                              {
                                              multi_key_reset_cnt = 0;
                              }
                              #endif
 770   1                              #if (RENOVATE_MODE == 1)        
                                      differ_mode1 = (long)n_base_line[addr] - (long)base_line[addr];
                                      if(differ_mode1 >= 0)//模式1differ判断
                                      {
                                              if(differ_mode1 >= (((int)fth)*WATER_FLOW_RATE/10))//模式1标志判断
                                              {
                                                              mode_flag |= ((long)0x01 << sensor_open[addr]); 
                                                              n_base_line_reno_count[addr] = 0;
                                              }
                                              else
                                              {
                                                              n_base_line_reno_count[addr]++;
                                                              if(n_base_line_reno_count[addr] >= N_BASE_LINE_RENO_MAX_COUNT)
                                                              {
                                                                              n_base_line[addr] -= differ_mode1/10;
                                                                              n_base_line_reno_count[addr] = 0;
                                                                              if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
                                                                              {
                                                                                      mode_flag &= ~((long)0x01 << sensor_open[addr]);
                                                                              }                                                               
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 14  

                                                              }
                                              }
                                      }
                                      else
                                      {
                                                      if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
                                                      {
                                                              
                                                              n_base_line[addr] -= differ_mode1/10;
                                                              
                                                      }
                                                      mode_flag &= ~((long)0x01 << sensor_open[addr]);        
                                      }
                                      
                      
                                      water_flow_key_count = 0;
                                      for(i = 0; i < SNS_NUM;i++)//模式1多按键判断
                                      {
                                              if((mode_flag & (((unsigned long)0x01) << sensor_open[i])))
                                              {
                                                      water_flow_key_count++;//模式1溢水计数
                                              }
                                              
                                      }
                                      
                              
                                      if(water_flow_key_count > WATER_FLOW_MAX_COUNT)//模式1溢水判断
                                      {
                                                      
                                                      water_flow_key_count = 0;
                                                      water_flow_key_reset_cnt++;             
                                                      if(water_flow_key_reset_cnt >= WATER_FLOW_RST_COUNT)
                                                      {
                                                              water_flow_key_reset_cnt = 0;
                                                              water_flow_left_count = 0;
                                                              if(water_flow_flag == 0)
                                                              {
                                                                      keys_flag= 0;
                                                                      Base_Line_Init();       
                                                                      water_flow_flag = 1;
                                                                      
                                                              }
                                                      }
                                                      
                                      }
                                      else
                                      {
                                              if(water_flow_flag == 1)//模式1溢水标志判断计数清除
                                              {
                                                              water_flow_left_count++;
                                                              if(water_flow_left_count >= WATER_FLOW_LEFT_MAX_COUNT)
                                                              {
                                                                      water_flow_flag = 0;
                                                                      water_flow_left_count = 0;
                                                              }
                                              }
                                              else
                                              {
                                                      water_flow_left_count = 0;
                                              }
                                      }
                              #endif
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 15  

 852   1      
 853   1                      if(differ > 0)//differ大于0情况
 854   1                      {
 855   2      
 856   2                              #if (RENOVATE_MODE == 1)
                                      //模式1
                                      if(water_flow_flag == 1)
                                      {
                                              if((mode_flag & (((unsigned long)0x01) << sensor_open[addr])))
                                              {
                                                              fth_tem = (fth_tem*RENOVATE_MODE1_FTH_RATE/10);//模式1手指阈值  
                                              }
                                      }
                                      #endif
 866   2                              
 867   2                              if(differ >= (fth_tem*RENOVATE_FTH_RATE/10))
 868   2                              {
 869   3                                              //有触摸，不作基线更新
 870   3                                              touch_confirm_count[addr]++;
 871   3                                              touch_left_count[addr] = 0;
 872   3                                              if(touch_confirm_count[addr] >= TK_COMFIRM_COUNT)
 873   3                                              {
 874   4                                                              keys_flag |= (((unsigned long)0x01) << sensor_open[addr]);
 875   4                                                              touch_confirm_count[addr] = 0;
 876   4                                              }
 877   3                                              else
 878   3                                              {
 879   4                                                      
 880   4                                              }
 881   3                                              
 882   3                              }
 883   2                              else if(differ >= (((int)fth)*RENOVATE_NTH_RATE/10))//>=p_noise基线更新
 884   2                              {
 885   3                                              #if (RENOVATE_MODE == 0)//模式0基线更新
 886   3                                                              
 887   3                                                              CTK_TK_Left_Count(addr);
 888   3                                      
 889   3                                                              over_p_noise_count[addr]++;
 890   3                                                              
 891   3                                                              under_p_noise_count[addr] = 0;
 892   3                                                              over_n_noise_count[addr] = 0;
 893   3                                                              under_n_noise_count[addr] = 0;
 894   3                                                              under_nn_noise_count[addr] = 0;
 895   3                                      
 896   3                                                              if(over_p_noise_count[addr] >= OVER_P_NOISE_MAX_COUNT)
 897   3                                                              {
 898   4                                                                      over_p_noise_count[addr] = 0;
 899   4                                                                      #if KEYS_RENOVATE_FLAG
 900   4                                                                      if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
 901   4                                                                      {
 902   5                                                                              
 903   5                                                                              #if     (c_xs_cs)
                                                                                              base_line[addr] -= c_xs_baseLindChangNum;
                                                                                      #else
 906   5                                                                                      base_line[addr] -= differ/5;
 907   5                                                                              #endif
 908   5                                                                              
 909   5                                                                      }
 910   4                                                                      #endif
 911   4                                                              }
 912   3                                              
 913   3                                              #endif                          
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 16  

 914   3                                              
 915   3                              }
 916   2                              else//differ<=p_noise基线更新
 917   2                              {
 918   3                                              #if (RENOVATE_MODE == 0)//模式0基线更新
 919   3                                                              CTK_TK_Left_Count(addr);
 920   3                                                              
 921   3                                                              over_p_noise_count[addr] = 0;
 922   3                                                              under_p_noise_count[addr]++;
 923   3                                                              over_n_noise_count[addr] = 0;
 924   3                                                              under_n_noise_count[addr] = 0;
 925   3                                                              under_nn_noise_count[addr] = 0;
 926   3                                                              if(under_p_noise_count[addr] >= UNDER_P_NOISE_MAX_COUNT)
 927   3                                                              {
 928   4                                                                      under_p_noise_count[addr] = 0;
 929   4                                                                      #if KEYS_RENOVATE_FLAG
 930   4                                                                      if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
 931   4                                                                      {
 932   5                                                                              #if     (c_xs_cs)
                                                                                              base_line[addr] -= c_xs_baseLindChangNum;
                                                                                      #else
 935   5                                                                                      base_line[addr] = raw_data[addr];
 936   5                                                                              #endif
 937   5                                                                      }
 938   4                                                                      #endif
 939   4                                                              }
 940   3                                              
 941   3                                              #endif
 942   3                                              #if (RENOVATE_MODE == 1)
                                                      //模式1基线更新
                                                                      CTK_TK_Left_Count(addr);
                                                                      over_p_noise_count[addr] = 0;
                                                                      under_p_noise_count[addr]++;
                                                                      over_n_noise_count[addr] = 0;
                                                                      under_n_noise_count[addr] = 0;
                                                                      under_nn_noise_count[addr] = 0;
                                                                      if(under_p_noise_count[addr] >= UNDER_P_NOISE_MAX_COUNT)
                                                                      {
                                                                              under_p_noise_count[addr] = 0;
                                                                              if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
                                                                              {                                                               
                                                                                      base_line[addr] = raw_data[addr];                                                       
                                                                              }
                                                                      }
                                                      
                                                      #endif
 960   3                              }
 961   2                      }
 962   1                      else//differ<0的情况
 963   1                      {
 964   2                              CTK_TK_Left_Count(addr);
 965   2                              if(differ >= (-(((int)fth)*RENOVATE_NTH_RATE/10)))//>= n_poise情况
 966   2                              {
 967   3                                              #if (RENOVATE_MODE == 0)//模式0基线更新
 968   3                                                      over_p_noise_count[addr] = 0;
 969   3                                                      under_p_noise_count[addr] = 0;
 970   3                                                      over_n_noise_count[addr]++;
 971   3                                                      under_n_noise_count[addr] = 0;
 972   3                                                      under_nn_noise_count[addr] = 0;
 973   3                                                      if(over_n_noise_count[addr] >= OVER_N_NOISE_MAX_COUNT)
 974   3                                                      {
 975   4                                                              over_n_noise_count[addr] = 0;
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 17  

 976   4                                                              #if KEYS_RENOVATE_FLAG
 977   4                                                              if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
 978   4                                                              {
 979   5                                                              
 980   5                                                                      #if     (c_xs_cs)
                                                                                      base_line[addr] += c_xs_baseLindChangNum;
                                                                              #else
 983   5                                                                              base_line[addr] = raw_data[addr];
 984   5                                                                      #endif  
 985   5                                                              
 986   5                                                              }
 987   4                                                              #endif
 988   4                                                      }
 989   3                                      
 990   3                                              #endif
 991   3                                                      
 992   3                                              #if (RENOVATE_MODE == 1)
                                                      //模式1基线更新
                                                      
                                                              over_p_noise_count[addr] = 0;
                                                              under_p_noise_count[addr] = 0;
                                                              over_n_noise_count[addr]++;
                                                              under_n_noise_count[addr] = 0;
                                                              under_nn_noise_count[addr] = 0;
                                                              if(over_n_noise_count[addr] >= OVER_N_NOISE_MAX_COUNT)
                                                              {
                                                                      over_n_noise_count[addr] = 0;
                                                                      #if KEYS_RENOVATE_FLAG
                                                                      if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
                                                                      {
                                                                      
                                                                              base_line[addr] = raw_data[addr];
                                                                      
                                                                      }
                                                                      #endif
                                                              }
                                                      
                                                      #endif
1014   3                              }
1015   2                              else if((differ >= -(UNDER_N*((int)fth)*RENOVATE_FTH_RATE/10)))
1016   2                              {
1017   3                                              #if (RENOVATE_MODE == 0)//模式0基线更新
1018   3                                                      over_p_noise_count[addr] = 0;
1019   3                                                      under_p_noise_count[addr] = 0;
1020   3                                                      over_n_noise_count[addr] = 0;
1021   3                                                      under_n_noise_count[addr]++;
1022   3                                                      under_nn_noise_count[addr] = 0;
1023   3                                      
1024   3                                                      if(under_n_noise_count[addr] >= UNDER_N_NOISE_MAX_COUNT)
1025   3                                                      {
1026   4                                                              under_n_noise_count[addr] = 0;
1027   4                                                              #if KEYS_RENOVATE_FLAG
1028   4                                                              if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
1029   4                                                              {
1030   5                                                                      #if     (c_xs_cs)
                                                                                              base_line[addr] += c_xs_baseLindChangNum;
                                                                              #else
1033   5                                                                                      base_line[addr] -= differ/2;    
1034   5                                                                      #endif                                          
1035   5                                                              }
1036   4                                                              #endif                                  
1037   4                                                              
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 18  

1038   4                                                      }
1039   3                                      #endif
1040   3                                              
1041   3                                      #if (RENOVATE_MODE == 1)//模式1基线更新
                                                              over_p_noise_count[addr] = 0;
                                                              under_p_noise_count[addr] = 0;
                                                              over_n_noise_count[addr] = 0;
                                                              under_n_noise_count[addr]++;
                                                              under_nn_noise_count[addr] = 0;
                                              
                                                              if(under_n_noise_count[addr] >= UNDER_N_NOISE_MAX_COUNT)
                                                              {
                                                                      under_n_noise_count[addr] = 0;
                                                                      #if KEYS_RENOVATE_FLAG
                                                                      if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
                                                                      {
                                                                                      base_line[addr] -= differ/2;                            
                                                                      }
                                                                      #endif                                  
                                                                      
                                                              }
                                              #endif
1060   3                              }
1061   2                              else
1062   2                              {
1063   3                                              #if (RENOVATE_MODE == 0)//模式0基线更新
1064   3                                              over_p_noise_count[addr] = 0;
1065   3                                              under_p_noise_count[addr] = 0;
1066   3                                              over_n_noise_count[addr] = 0;
1067   3                                  under_n_noise_count[addr] = 0;
1068   3                                              under_nn_noise_count[addr]++;                   
1069   3                                              if(under_nn_noise_count[addr] >= UNDER_NN_NOISE_MAX_COUNT)
1070   3                                              {
1071   4                                                      under_nn_noise_count[addr] = 0;
1072   4                                                      
1073   4                                                      #if KEYS_RENOVATE_FLAG
1074   4                                                      if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
1075   4                                                      {
1076   5                                                              #if     (c_xs_cs)
                                                                              base_line[addr] += c_xs_baseLindChangNum;
                                                                      #else
1079   5                                                                      base_line[addr] -= differ/5;    
1080   5                                                              #endif                                                  
1081   5                                                      }
1082   4                                                      #endif
1083   4                                              }       
1084   3                                              #endif
1085   3                                              
1086   3                                              #if (RENOVATE_MODE == 1)//模式1基线更新
                                                      over_p_noise_count[addr] = 0;
                                                      under_p_noise_count[addr] = 0;
                                                      over_n_noise_count[addr] = 0;
                                          under_n_noise_count[addr] = 0;
                                                      under_nn_noise_count[addr]++;                   
                                                      if(under_nn_noise_count[addr] >= UNDER_NN_NOISE_MAX_COUNT)
                                                      {
                                                              under_nn_noise_count[addr] = 0;
                                                              
                                                              #if KEYS_RENOVATE_FLAG
                                                                      if(KEYS_RENOVATE_FLAG &(((unsigned long)0x01)<<sensor_open[addr]))
                                                                      {
                                                                              base_line[addr] -= differ/5;                                    
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 19  

                                                                      }
                                                              #endif
                                                      }       
                                                      #endif
1104   3                              }
1105   2                      }
1106   1              }
1107                  
1108                  //-----------------------------------------------------------------//
1109                  //函数名称： void CTK_XS16TK06X_Adjust_Int(void)
1110                  //函数功能：通道电流源自适应
1111                  //输入参数： 无
1112                  //输出参数： 无
1113                  //返 回 值： 无
1114                  //-----------------------------------------------------------------//        
1115          
1116                  void CTK_XS16TK06X_Adjust_Int(void)
1117                  {
1118   1                      if(adjust_count < 3)
1119   1                      {
1120   2                              while(1)
1121   2                              {
1122   3                                      WDT_CTRL = 7;
1123   3                                      
1124   3                                      if((raw_data[sns_next] >= ADJUST_LINE))
1125   3                                      {
1126   4                                              if(pull_i_value[sns_next] < (511 - ADJUST_STE))
1127   4                                              {
1128   5                                                      pull_i_value[sns_next] += (1 + ADJUST_STE);
1129   5                                                      Set_Next_SNS();
1130   5                                                      return;
1131   5                                              }       
1132   4                                              else
1133   4                                              {
1134   5                                                      
1135   5                                                      sns_next++;
1136   5                                                      if(sns_next >= SNS_NUM)
1137   5                                                      {
1138   6                                                                      sns_next = 0;
1139   6                                                                      adjust_count = 0;
1140   6                                                                      adjust_done_flag = 1;//自适应完成
1141   6                                                                      
1142   6                                                      }
1143   5                                                      
1144   5                                                      Set_Next_SNS();
1145   5                                                      return;
1146   5                                              }
1147   4                                      }
1148   3                                      else
1149   3                                      {       
1150   4                                                      n_base_line[sns_next] = base_line[sns_next] = raw_data[sns_next];
1151   4                                                      sns_next++;
1152   4                                                      if(sns_next >= SNS_NUM)
1153   4                                                      {
1154   5                                                                      if(adjust_count < 3)
1155   5                                                                      {
1156   6                                                                              adjust_count++;
1157   6                                                                      }
1158   5      
1159   5                                                                      sns_next = 0;
1160   5                                                                      if(pull_i_value[sns_next] > (0))
1161   5                                                                      {
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 20  

1162   6                                                                              pull_i_value[sns_next] -= (1);
1163   6                                                                              Set_Next_SNS();
1164   6                                                                              return;
1165   6                                                                      }
1166   5                                                              
1167   5                                                                      Set_Next_SNS();
1168   5                                                                      break;
1169   5                                                      }
1170   4      
1171   4                                                      if(pull_i_value[sns_next] > (0))
1172   4                                                      {
1173   5                                                              pull_i_value[sns_next] -= (1);
1174   5                                                              Set_Next_SNS();
1175   5                                                              return;
1176   5                                                      }
1177   4                                                      else
1178   4                                                      {
1179   5                                                                      Set_Next_SNS();
1180   5                                                                      return;
1181   5                                                      }       
1182   4                                      }
1183   3                              }
1184   2                      }
1185   1                      
1186   1                      if(adjust_count >= 3)
1187   1                      {
1188   2                              while(1)
1189   2                              {
1190   3                                      WDT_CTRL = 7;
1191   3                                      
1192   3                                      if((raw_data[sns_next] <= ADJUST_LINE))
1193   3                                      {
1194   4                                              if(pull_i_value[sns_next] > (0))
1195   4                                              {
1196   5                                                      pull_i_value[sns_next] -= (1);
1197   5                                                      Set_Next_SNS();
1198   5                                                      return;
1199   5                                              }       
1200   4                                              else
1201   4                                              {
1202   5                                                      sns_next++;
1203   5                                                      if(sns_next >= SNS_NUM)
1204   5                                                      {
1205   6                                                                      sns_next = 0;
1206   6                                                                      adjust_count = 0;
1207   6                                                                      adjust_done_flag = 1;
1208   6                                                                      
1209   6                                                      }
1210   5                                                      
1211   5                                                      Set_Next_SNS();
1212   5                                                      
1213   5                                                      return;
1214   5                                              }
1215   4                                              
1216   4                                      }
1217   3                                      else
1218   3                                      {       
1219   4                                                      n_base_line[sns_next] = base_line[sns_next] = raw_data[sns_next];
1220   4                                                      sns_next++;
1221   4                                                      if(sns_next >= SNS_NUM)
1222   4                                                      {
1223   5                                                                      sns_next = 0;
C51 COMPILER V9.60.0.0   XS16TK06X_TK                                                      05/09/2023 16:49:05 PAGE 21  

1224   5                                                              
1225   5                                                                      if(adjust_count < 6)
1226   5                                                                      {
1227   6                                                                              adjust_count++;
1228   6                                                                      }
1229   5                                                                      if(adjust_count >= 6)
1230   5                                                                      {
1231   6                                                                              adjust_count = 0;
1232   6                                                                              adjust_done_flag = 1;
1233   6                                                                      }
1234   5                                                                      Set_Next_SNS();
1235   5                                                                      break;
1236   5                                                      }
1237   4              
1238   4                                                      if(pull_i_value[sns_next] < (511 - ADJUST_STE))
1239   4                                                      {
1240   5                                                              pull_i_value[sns_next] += (1 + ADJUST_STE);
1241   5                                                              Set_Next_SNS();
1242   5                                                              return;
1243   5                                                      }
1244   4                                                      else
1245   4                                                      {
1246   5                                                                      Set_Next_SNS();
1247   5                                                                      return;
1248   5                                                      }       
1249   4                                      }
1250   3                              }
1251   2                      }
1252   1              }
1253                  
1254          #endif
1255          //////////TK////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2938    ----
   CONSTANT SIZE    =    130    ----
   XDATA SIZE       =    190       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
