C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE WORK_DEAL
OBJECT MODULE PLACED IN .\Output\WORK_DEAL.obj
COMPILER INVOKED BY: D:\Program_Files\KEIL5_521A\C51\BIN\C51.EXE Application_Library\WORK_DEAL.c OMF2 OPTIMIZE(8,SPEED) 
                    -BROWSE INCDIR(.\Inc;.\User;.\Application_Library;.\Project) DEBUG PRINT(.\List\WORK_DEAL.lst) OBJECT(.\Output\WORK_DEAL.
                    -obj)

line level    source

   1          #include        "..\Application_Library\Global.h"
   2          
   3          
   4          uchar   xdata   b_mode=0;
   5          uchar   xdata   b_ctrl_status=0;
   6          uchar f_out_out =0;
   7          uchar xdata     b_wendu_ok=0;   //达到目标温度的次数
   8          uchar   xdata   b_wendu_min=0;
   9          
  10          uchar   xdata   b_mjs_set_sec=0;
  11          
  12          uchar   xdata   b_baowen_hour=0;
  13          uchar   xdata   b_baowen_min=0;
  14          uchar   xdata   b_baowen_sec=0;
  15          
  16          uchar   xdata   b_yuyue_hour=0;
  17          uchar   xdata   b_yuyue_min=0;
  18          uchar   xdata   b_yuyue_sec=0;
  19          
  20          uchar   xdata   b_dingshi_hour=0;
  21          uchar   xdata   b_dingshi_min=0;
  22          uchar   xdata   b_dingshi_sec=0;
  23          
  24          uchar   xdata   b_ctrl_sec_1=0;
  25          uchar   xdata   b_ctrl_cnt=0;
  26          uchar   xdata   b_ctrl_cnt1=0;
  27          uchar   xdata   b_ctrl_cnt2=0;
  28          uint    xdata   b_ctrl_sec_2=0;
  29          uchar   xdata   b_ctrl_sec_3=0;
  30          
  31          
  32          uchar   xdata   b_grade=0;      //档位
  33          uchar   xdata   b_set_wendu=0;  //设定的温度
  34          
  35          uchar xdata b_yuyue_run_cnt =0; //预约倒计时进行时长计数
  36          
  37          
  38          
  39          /*暖菜机定义*/
  40          bit             f_sys_power_1=0;  //左边(A) 0:关,1:开
  41          bit             f_sys_power_2=0;  //右边(B) 0:关,1:开
  42          //
  43          bit     f_sys_on_1=0;     //左边(A) 0:待机,1:开机
  44          bit     f_sys_on_2=0;     //左边(A) 0:待机,1:开机
  45          
  46          
  47          
  48          uchar   tab_huo_guo_9[] = {5,10,15,20,25,30,35,40,45};
  49          uchar   tab_huo_guo_5[] = {25,30,35,40,45};
  50          
  51          
  52          
  53          #if     double_ad_channel
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 2   

              uchar   xdata   b_temp_1_ref_sec=0;
              uchar   xdata   b_temp_1_ref=0;
              #endif
  57          
  58          
  59          
  60          bit     f_power_power=0;
  61          
  62          //主状态
  63          bit     f_mjs_set=0;
  64          bit     f_mjs_dingshi=0;
  65          bit     f_mjs_yuyue=0;
  66          bit     f_mjs_power=0;
  67          bit     f_mjs_down=0;
  68          bit     f_dingshi_begin=0;
  69          
  70          
  71          bit     f_NO_jiangdang=0;       //降档标志位 0:可降档 1:不可降档
  72          
  73          
  74          bit             f_relay_change=0;
  75          bit             f_jdq=0;
  76          bit             f_jdq2=0;
  77          bit             f_jdq3=0;
  78          
  79          bit             f_test=0;
  80          uchar   xdata   b_test=0;
  81          uchar   xdata   b_test_out_time=0;
  82          uchar   xdata   b_test_mode=0;
  83          
  84          #if   kkg_en
  85          uchar   xdata   b_zeor_pre=0;
  86          uchar   xdata   b_delay_kkg=0;
  87          uint    xdata   b_out_ctrl=0;
  88          uint    xdata   b_out_ctrl2=0;
  89          
  90          
  91          uchar   xdata   b_kkg_count=0;
  92          uchar   xdata   b_high_level=0; //左可控硅,高电平时间1
  93          
  94          uchar   xdata   gb_kkg=0;
  95          uchar   xdata   b_kkg_buf=0;
  96          bit             f_delay_kkg=0;
  97          bit             f_high_time=0;  //左可控硅 0:关闭,1:输出
  98          #endif
  99          
 100          
 101          void    work_deal();    //工作处理
 102          
 103          void    next_step();    //下一流程
 104          void    shutdown_power();
 105          void    gaoyuan_heat(uchar b_para);
 106          void    heat_hdle(uchar b_parameter);   //间断性加热
 107          void    intermittent(uint b_on,uint b_all);     //间断性加热
 108          
 109          void    baowen_hdle(uchar b_temp1,uchar b_temp2,uchar b_para);  //在指定温度内,按占空比加热
 110          void    three_heat(uchar b_wdvalue,uchar heat1,uchar tmp1,uchar heat2,uchar tmp2,uchar heat3,uchar tmp3,uchar
             - heat4);
 111          void    action_work();
 112          void    quit_work();
 113          
 114          
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 3   

 115          
 116          #if 1   //其他流程
 117          void    zhu_mode_0();   //流程1
 118          void    zhu_mode_1();   //流程1
 119          
 120          void    zhu_mode_4();   //流程4
 121          
 122          
 123          void    zhu_mode_chao();        //爆炒,火锅 流程1,6
 124          void    zhu_mode_dunzhu();      //炖煮          流程2
 125          void    zhu_mode_qingzheng();//清蒸             流程3
 126          void    zhu_mode_mandun();      //慢炖          流程4
 127          void    zhu_mode_niupai();      //牛排      流程5
 128          void    zhu_mode_bb();  //保温
 129          void    zhu_mode_chao_SP()      ;
 130          
 131          
 132          void    baowen_mode_hdle();     //保温流程
 133          void    zhufan_hdle_ONE();      //煮饭流程
 134          
 135          
 136          
 137          
 138          
 139          #endif
 140          
 141          
 142          //      流程声明
 143          #if 0   //饭煲 双探头流程
              /*双探头流程*/
              void    tang_hdle_TWO();        //煲汤流程
              void    zhuzhou_hdle_TWO();     //煮粥流程
              void    tangshui_hdle_TWO();//糖水流程
              void    zhufan_hdle_TWO();      //煮饭流程
              void    zheng_hdle_TWO();       //蒸流程
              #endif
 151          
 152          #if 0   //饭煲 单探头流程
              /*单探头流程*/
              void    tang_hdle_ONE();        //煲汤流程
              void    zheng_hdle_ONE();       //蒸流程
              void    zhuzhou_hdle_ONE();     //煮饭流程
              void    zhufan_hdle_ONE();      //煮饭流程
              void    dangao_hdle_ONE();      //蛋糕流程
              void    suannai_hdle_ONE(); //酸奶流程
              void    dun_hdle_ONE();         //炖流程
              void    refan_hdle_ONE();       //热饭流程
              #endif
 163          
 164          
 165          
 166          /*-----------------------------------------------------------------
 167          函数名称： void work_deal(void)
 168          函数功能： 工作处理
 169          输入参数： 无
 170          返 回 值： 无
 171          -----------------------------------------------------------------*/
 172          void    work_deal()
 173          {
 174   1          //uint b_share_cnt1,b_share_cnt2;
 175   1          uchar   b_jdq_buf_1=0;    //可控硅输出缓存左
 176   1          f_jdq=0;    //继电器 关
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 4   

 177   1              b_kkg_buf=0;    //可控硅关
 178   1      
 179   1              /*不在爆炒,清*/
 180   1              if(b_mode!=1)
 181   1                      b_wendu_ok=0;   //达到目标温度的次数
 182   1      
 183   1      
 184   1      
 185   1      
 186   1              /*待机状态下,清模式*/
 187   1          if(!(f_mjs_set||f_mjs_yuyue||f_mjs_dingshi||f_mjs_power))
 188   1          {
 189   2                      b_mode=0;
 190   2      
 191   2              }    
 192   1                      
 193   1              /*不在运行状态,不能倒计时标志位*/
 194   1          if(!f_mjs_power)
 195   1              f_dingshi_begin=0;
 196   1              /*在设置状态,清预约秒*/
 197   1              /*不在预约状态,清预约秒*/
 198   1          if(f_mjs_set||(!f_mjs_yuyue))
 199   1              b_yuyue_sec=0;
 200   1              /*在设置状态,清定时秒*/
 201   1              /*不在定时状态,清定时秒*/
 202   1              /*在预约状态,清定时秒*/
 203   1              /*倒计时标志位没打开,清定时秒*/
 204   1          if(f_mjs_set||(!f_mjs_dingshi)||f_mjs_yuyue||(!f_dingshi_begin))
 205   1              b_dingshi_sec=0;
 206   1              /*不在保温模式,清保温时间*/
 207   1          if(b_mode!=0x80)
 208   1          {
 209   2              b_baowen_sec=0;
 210   2              b_baowen_min=0;
 211   2              b_baowen_hour=0;
 212   2          }
 213   1      
 214   1      
 215   1      
 216   1          if(!b_warning)
 217   1          {
 218   2                      /*设置状态*/
 219   2              if(f_mjs_set)
 220   2              {
 221   3                  if(b_mjs_set_sec>=5)
 222   3                 {
 223   4                      if(b_mode)
 224   4                                      {
 225   5                                              action_work();  //开始工作
 226   5                                              b_time_grade_cnt=0;//;0:档位,5:时间
 227   5                                      }
 228   4                      else
 229   4                          shutdown_power();//关闭所有功能
 230   4                      //quit_work();
 231   4                  }
 232   3              }
 233   2      
 234   2      
 235   2                      /*预约状态*/
 236   2              if(f_mjs_yuyue)
 237   2              {
 238   3                  if(!f_mjs_set)
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 5   

 239   3                  {
 240   4                              #if     c_yyyc  //为1则预约时间为完成时间
                              b_share_cnt1=b_odon_hour*60+b_odon_min;
                              b_share_cnt2=b_odoff_hour*60+b_odoff_min;
                              if(b_share_cnt2>=b_share_cnt1)
                                      #else
 245   4                                      /*预约时间清零,则表示预约完成*/
 246   4                      if(b_yuyue_hour==0 && b_yuyue_min==0)
 247   4                              #endif
 248   4                      {
 249   5                          f_mjs_yuyue=0;
 250   5                                              f_mjs_dingshi=1;
 251   5                                              f_mjs_power=1;
 252   5      
 253   5                                              f_disp_yuyue=0;
 254   5                          
 255   5                          next_step();        //下一流程
 256   5                          b_ctrl_status=0;
 257   5                          open_buz(1);        //工作开始音    
 258   5                      }
 259   4                  }
 260   3                      }
 261   2      
 262   2              //      工作时间
 263   2              if(f_mjs_dingshi&&f_dingshi_begin)
 264   2              {
 265   3                  if(!f_mjs_set)
 266   3                  {
 267   4                      if((b_dingshi_hour==0) && (b_dingshi_min==0) &&(b_mode!=0x80))
 268   4                      {
 269   5      
 270   5                          quit_work();
 271   5                          //if(b_mode!=4)
 272   5                          open_buz(3);        //工作完成音
 273   5                                              
 274   5                          if(b_mode==2 || b_mode==3 ||b_mode==4||b_mode==5)   //功能1,3,4可转保温条件,有酸奶时需要
             -修改此处
 275   5                          {
 276   6                              f_mjs_power=1;
 277   6                                                      f_mjs_dingshi=1;
 278   6                                                      f_dingshi_begin=1;
 279   6                              //b_mode=0xff;
 280   6                                                      b_mode=0x80;    //保温模式
 281   6                                                      /*设置默认温度*/
 282   6                                                      b_set_wendu=60; //60℃
 283   6              
 284   6                                                      /*初始化时间*/
 285   6                                                      b_dingshi_hour=24;
 286   6                                                      b_dingshi_min=0;
 287   6                                                      b_dingshi_sec=0;                        
 288   6      
 289   6      
 290   6      
 291   6      
 292   6                                                      ////初始化保温时间
 293   6                                                      //b_baowen_hour=0;
 294   6                                                      //b_baowen_min=0;
 295   6                                                      //b_baowen_sec=0;
 296   6      
 297   6                                                       
 298   6                              next_step();    //下一流程
 299   6                              b_ctrl_status=0;
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 6   

 300   6                          }
 301   5                      }
 302   4      
 303   4                  }
 304   3              }
 305   2      
 306   2      
 307   2              //      工作流程
 308   2              if(f_mjs_power)
 309   2              {
 310   3                  switch(b_mode)
 311   3                  {
 312   4                      case 1://爆炒
 313   4                          zhu_mode_chao_SP(); //爆炒,火锅 OK
 314   4                          break;
 315   4                              case 2://炖煮
 316   4                                              zhu_mode_dunzhu();      //炖煮  OK
 317   4                              break;
 318   4                      case 3://清蒸
 319   4                              //zhufan_hdle_ONE();//煮饭流程
 320   4                                              zhu_mode_qingzheng();   //清蒸 OK
 321   4                              break;
 322   4                      case 4://慢炖
 323   4                          zhu_mode_mandun();
 324   4                          break;
 325   4                      case 5:
 326   4                                              //牛排
 327   4                          zhu_mode_niupai();
 328   4                          break;
 329   4                      case 6://火锅
 330   4                          zhu_mode_chao();    //OK
 331   4                          break;
 332   4      
 333   4                      case 0x80://保温
 334   4                      {
 335   5                                              zhu_mode_bb();  //保温模式
 336   5                                              break;
 337   5                      }
 338   4                  default:
 339   4                      shutdown_power();
 340   4                      break;
 341   4                  }
 342   3              }               
 343   2      
 344   2      
 345   2                      /*超温保护*/
 346   2              if(gb_wendu>=220)
 347   2                      {
 348   3                              f_jdq=0;
 349   3                              b_kkg_buf=0;
 350   3                      }
 351   2      
 352   2      
 353   2      
 354   2      
 355   2              }
 356   1      
 357   1      
 358   1      #if   kkg_en
 359   1          ///*左可控硅*/
 360   1          //if(f_jdq)
 361   1          //{
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 7   

 362   1          //  if(f_test)
 363   1          //    gb_kkg=10;
 364   1          //  else
 365   1          //  {
 366   1          //      gb_kkg=b_jdq_buf_1;
 367   1          //  }
 368   1          //}
 369   1          //else
 370   1          //  gb_kkg=0;
 371   1      
 372   1      
 373   1              gb_kkg = b_kkg_buf;
 374   1      
 375   1      
 376   1      #endif
 377   1      
 378   1      }
 379          
 380          
 381          
 382          
 383          
 384          /*-----------------------------------------------------------------
 385          函数名称： void three_heat(void)
 386          函数功能： 三段加热      右移原则
 387          输入参数： b_wdvalue   heat1  tmp1  heat2  tmp2  heat3 tmp3  heat4
 388          返 回 值： 无
 389          -----------------------------------------------------------------*/
 390          void    three_heat(uchar b_wdvalue,uchar heat1,uchar tmp1,uchar heat2,uchar tmp2,uchar heat3,uchar tmp3,uchar
             - heat4)
 391          {
 392   1          if(b_wdvalue<tmp1)
 393   1              heat_hdle(heat1);
 394   1          else if(b_wdvalue<tmp2)
 395   1              heat_hdle(heat2);
 396   1          else if(b_wdvalue<tmp3)
 397   1              heat_hdle(heat3);
 398   1          else
 399   1              heat_hdle(heat4);
 400   1      }
 401          
 402          
 403          #if     double_ad_channel
              /*-----------------------------------------------------------------
              函数名称： void gaoyuan_heat(void)
              函数功能： 高原加热
              输入参数： b_para 加热温度
              返 回 值： 无
              -----------------------------------------------------------------*/
              void    gaoyuan_heat(uchar b_para)
              {
                  if(gb_wendu2>=b_para)
                      next_step();
              
                  if(gb_wendu2>=80)
                  {
                      if((gb_wendu2<(b_temp_1_ref+2)) && (gb_wendu2>(b_temp_1_ref-2)))
                      {
                          if(b_temp_1_ref_sec>=120)
                              next_step();
                      }
                      else
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 8   

                      {
                          b_temp_1_ref=gb_wendu2;
                          b_temp_1_ref_sec=0;
                      }
                  }
                  else
                  {
                      b_temp_1_ref=gb_wendu2;
                      b_temp_1_ref_sec=0;
                  }
              
              }
              #endif
 436          
 437          
 438          /*-----------------------------------------------------------------
 439          函数名称： void baowen_hdle(void)
 440          函数功能： 在指定温度内,按占空比加热
 441          输入参数： b_temp1 低温         b_temp2 高温      b_para 占空比
 442          返 回 值： 无
 443          -----------------------------------------------------------------*/
 444          void    baowen_hdle(uchar b_temp1,uchar b_temp2,uchar b_para)
 445          {
 446   1          if(gb_wendu<b_temp1)
 447   1              f_power_power=1;
 448   1          if(gb_wendu>b_temp2)
 449   1              f_power_power=0;
 450   1          if(f_power_power)
 451   1              heat_hdle(b_para);
 452   1      }
 453          
 454          /*-----------------------------------------------------------------
 455          函数名称： void heat_hdle(void)
 456          函数功能： 间断性加热      周期为40秒
 457          输入参数： 加热时间
 458          返 回 值： 无
 459          -----------------------------------------------------------------*/
 460          void    heat_hdle(uchar b_parameter)
 461          {
 462   1          if(b_ctrl_sec_2>=40)
 463   1              b_ctrl_sec_2=0;
 464   1          if(b_ctrl_sec_2>=b_parameter)
 465   1              f_jdq=0;
 466   1          else
 467   1              f_jdq=1;
 468   1      }
 469          
 470          
 471          /*-----------------------------------------------------------------
 472          函数名称： void intermittent(uchar b_all,uchar b_on)
 473          函数功能： 间断性加热      周期为40秒
 474          输入参数： 加热时间
 475          返 回 值： 无
 476          -----------------------------------------------------------------*/
 477          void    intermittent(uint b_on,uint b_all)
 478          {
 479   1          if(b_ctrl_sec_2>=b_all)
 480   1              b_ctrl_sec_2=0;
 481   1          if(b_ctrl_sec_2>=b_on)
 482   1              f_jdq=0;
 483   1          else
 484   1              f_jdq=1;
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 9   

 485   1      }
 486          
 487          
 488          
 489          /*-----------------------------------------------------------------
 490          函数名称： void shutdown_power(void)
 491          函数功能： 关闭所有功能
 492          输入参数： 无
 493          返 回 值： 无
 494          -----------------------------------------------------------------*/
 495          void    shutdown_power()
 496          {
 497   1          //open_buz(1);
 498   1              open_buz(3);    //完成音
 499   1          quit_work();
 500   1      }
 501          
 502          
 503          /*-----------------------------------------------------------------
 504          函数名称： void next_step(void)
 505          函数功能： 下一流程
 506          输入参数： 无
 507          返 回 值： 无
 508          -----------------------------------------------------------------*/
 509          void    next_step()
 510          {
 511   1          f_power_power=0;
 512   1          b_ctrl_cnt=0;
 513   1          b_ctrl_cnt1=0;
 514   1          b_ctrl_cnt2=0;
 515   1      
 516   1          b_ctrl_sec_1=0;
 517   1          b_ctrl_sec_2=0;
 518   1          b_ctrl_sec_3=0;
 519   1      
 520   1          b_ctrl_status++;
 521   1          b_wendu_min=0xff;
 522   1      
 523   1      #if   double_ad_channel
                  b_temp_1_ref_sec=0;
                  b_temp_1_ref=gb_wendu2;
              #endif
 527   1      }
 528          
 529          
 530          /*-----------------------------------------------------------------
 531          函数名称： void quit_work(void)
 532          函数功能： 退出工作
 533          输入参数： 无
 534          返 回 值： 无
 535          -----------------------------------------------------------------*/
 536          void    quit_work()
 537          {       
 538   1              /*显示*/
 539   1          f_disp_yuyue=0;
 540   1          f_disp_dingshi=0;
 541   1      
 542   1              /*主状态*/
 543   1          f_mjs_dingshi=0;
 544   1          f_mjs_yuyue=0;
 545   1          f_mjs_set=0;
 546   1          f_mjs_power=0;
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 10  

 547   1          f_mjs_down=0;
 548   1      
 549   1              f_dingshi_begin=0;
 550   1      
 551   1          f_jdq=0;
 552   1      }
 553          
 554          /*-----------------------------------------------------------------
 555          函数名称： void action_work(void)
 556          函数功能： 开始工作
 557          输入参数： 无
 558          返 回 值： 无
 559          -----------------------------------------------------------------*/
 560          void    action_work()
 561          {
 562   1          //open_buz(4);      //工作开始音
 563   1          f_mjs_set=0;        //关闭设置状态
 564   1      
 565   1              b_wendu_ok=1;
 566   1          //b_led_slide1=5;
 567   1          //f_disp_yuyue=0;
 568   1          //f_disp_dingshi=0;
 569   1      
 570   1              /*非预约状态下,运行*/
 571   1          if(!f_mjs_yuyue)
 572   1          {
 573   2              next_step();
 574   2              f_mjs_power=1;
 575   2              b_ctrl_status=0;
 576   2          }
 577   1      }
 578          
 579          
 580          
 581          #if out_en
 582          /*-----------------------------------------------------------------
 583          函数名称： void relay_deal(void)
 584          函数功能： 继电器输出控制,100ms基准
 585          输入参数： 无
 586          返 回 值： 无
 587          -------------------------------------------------------------------*/
 588          void    relay_deal()
 589          {
 590   1          if(f_relay_change)
 591   1          {
 592   2              f_relay_change=0;
 593   2      
 594   2              if(f_jdq)
 595   2              {
 596   3                  p_out1h;
 597   3              }
 598   2              //if(f_jdq2)
 599   2              //{
 600   2              //    p_out2h;
 601   2              //}
 602   2              //if(f_jdq3)
 603   2              //{
 604   2              //    p_out3h;
 605   2              //}
 606   2          }
 607   1          else
 608   1          {
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 11  

 609   2              f_relay_change=1;
 610   2      
 611   2              if(!f_jdq)
 612   2              {
 613   3                  p_out1l;
 614   3              }
 615   2              //if(!f_jdq2)
 616   2              //{
 617   2              //    p_out2l;
 618   2              //}
 619   2              //if(!f_jdq3)
 620   2              //{
 621   2              //    p_out3l;
 622   2              //}
 623   2          }
 624   1      }
 625          #endif
 626          
 627          
 628          #if   kkg_en
 629          
 630          void    kkg_work_api()
 631          {
 632   1          if(p_zero!=b_zeor_pre)
 633   1          {
 634   2      
 635   2            if(p_zero!=b_zeor_pre)
 636   2            {
 637   3              
 638   3              b_out_ctrl=0;
 639   3              b_zeor_pre=p_zero;
 640   3              b_delay_kkg=0;
 641   3              f_delay_kkg=1;
 642   3              
 643   3              /*左可控硅*/
 644   3              if(b_kkg_count<gb_kkg)
 645   3                  f_high_time=1;
 646   3              else
 647   3                  f_high_time=0;
 648   3              b_high_level=0;     //高电平时间1
 649   3              
 650   3      
 651   3              b_kkg_count++;
 652   3              if(b_kkg_count>=100)   //96  //过EMC电压闪烁加大此丢波周期，开通周期相应加大
 653   3                  b_kkg_count=0;
 654   3              
 655   3      
 656   3            }
 657   2            else
 658   2            {
 659   3                /*
 660   3                if(b_out_ctrl<=30000)
 661   3                    b_out_ctrl++;
 662   3               */
 663   3            }
 664   2          }
 665   1          else
 666   1          {
 667   2              /*
 668   2              if(b_out_ctrl<=30000)
 669   2                  b_out_ctrl++;
 670   2              */
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 12  

 671   2          }
 672   1      
 673   1          if(b_out_ctrl>=24000)    //2s无过零则断开所有输出
 674   1          {
 675   2            
 676   2            if(!b_warning&&gb_kkg)
 677   2            {
 678   3              //quit_work();
 679   3              //b_warning|=0x01;
 680   3              //b_error_sec=0;
 681   3              //open_buz(2);
 682   3            }
 683   2              #if   c_high_drive
                              p_kkgl;
                              p_kkg_Bl;
                      #else
 687   2                      p_kkgh;
 688   2                      p_kkg_Bh;
 689   2              #endif
 690   2          }
 691   1          else
 692   1          {
 693   2              
 694   2              /*左可控硅*/
 695   2              if(f_high_time)
 696   2              {
 697   3                  #if   c_high_drive
                              p_kkgh;
                          #else
 700   3                      p_kkgl;
 701   3                  #endif
 702   3      
 703   3                  if(b_high_level>=48)
 704   3                  {
 705   4                      #if   c_high_drive
                                  p_kkgl;
                              #else
 708   4                          p_kkgh;
 709   4                      #endif
 710   4                          f_high_time=0;
 711   4                  }
 712   3                  b_high_level++;
 713   3              }
 714   2              else
 715   2              {
 716   3                  #if   c_high_drive
                              p_kkgl;
                          #else
 719   3                      p_kkgh;
 720   3                  #endif
 721   3              }
 722   2      
 723   2          }
 724   1      }
 725          #endif
 726          
 727          
 728          
 729          
 730          #if 1 //其他流程
 731          
 732          void    zhu_mode_0()    //蒸煮,一直全功率加热,直接结束
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 13  

 733          {
 734   1              f_dingshi_begin=1;
 735   1              f_jdq=1;
 736   1      
 737   1      }
 738          
 739          
 740          
 741          void    zhu_mode_1()    
 742          {
 743   1              
 744   1          uchar temp=0;
 745   1              f_dingshi_begin=1;
 746   1              /*计时*/
 747   1          if(b_ctrl_sec_1>=60)
 748   1          {
 749   2              b_ctrl_sec_1=0;
 750   2                      if(b_ctrl_cnt<255)
 751   2                      b_ctrl_cnt++;
 752   2          }
 753   1      
 754   1      
 755   1      
 756   1              /*15分钟后降功率*/
 757   1              if((b_ctrl_cnt >= 15))  
 758   1              {
 759   2                      temp=13;
 760   2                      intermittent((uint)temp,45);    //间歇性加热
 761   2              }   
 762   1              else
 763   1              {
 764   2                      //一开始全功率
 765   2                      temp=45;
 766   2                      intermittent((uint)temp,45);    //间歇性加热
 767   2              }
 768   1      
 769   1      }       
 770          
 771          
 772          void    zhu_mode_chao() //煎炒,一直煮,指导手动关闭
 773          {
 774   1              uchar   temp=0;
 775   1      
 776   1              //f_dingshi_begin=1;
 777   1              /*计时*/
 778   1          if(b_ctrl_sec_1>=200)
 779   1          {
 780   2              b_ctrl_sec_1=200;
 781   2          }
 782   1      
 783   1              /*爆炒模式,没有6次P3.而是直接可以调功率*/
 784   1              if(b_mode==1)
 785   1              {
 786   2                      b_ctrl_sec_1=200;
 787   2              }
 788   1      
 789   1      
 790   1              /*前118s,开10停8*/
 791   1              /*后面按照档位来*/
 792   1              if(b_ctrl_sec_1<112)
 793   1              {
 794   2                      intermittent(10,18);    //间歇性加热
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 14  

 795   2              }
 796   1              else
 797   1              {
 798   2                      //间歇性加热
 799   2                      temp=tab_huo_guo_5[b_grade-1];
 800   2                      intermittent((uint)temp,18);    //间歇性加热
 801   2              }
 802   1      
 803   1      }
 804          
 805          //煎炒,有点特殊
 806          void    zhu_mode_chao_SP()      
 807          {
 808   1              //static uchar b_wendu_ok=0;    //达到目标温度的次数
 809   1              uchar   temp=0; 
 810   1              uchar   b_i=0;
 811   1              b_set_wendu =200;
 812   1      
 813   1          if(b_ctrl_sec_1>=60)
 814   1          {
 815   2              b_ctrl_sec_1=0;
 816   2                      if(b_ctrl_cnt<255)
 817   2                      b_ctrl_cnt++;
 818   2          }
 819   1      
 820   1      
 821   1              if(b_wendu_ok==1)
 822   1              {
 823   2                      if (gb_wendu < b_set_wendu-80)
 824   2                      {
 825   3                              //f_jdq=1;
 826   3                              b_kkg_buf=0;
 827   3      
 828   3                              //间歇性加热
 829   3                              temp=tab_huo_guo_5[b_grade-1];
 830   3                              intermittent(temp,45);  //间歇性加热
 831   3                              
 832   3                      }               
 833   2                      else
 834   2                      {
 835   3                              f_jdq=0;
 836   3                              b_kkg_buf=((b_set_wendu-gb_wendu)/6);
 837   3                      }
 838   2                      if(gb_wendu>=b_set_wendu)
 839   2                      {
 840   3                              b_wendu_ok=2;
 841   3                      }
 842   2                      
 843   2                      if(b_grade>=4)
 844   2                              b_i=2;
 845   2                      else if(b_grade>=2)     
 846   2                      {
 847   3                              b_i=3;
 848   3                      }
 849   2                      else
 850   2                      {
 851   3                              b_i=4;  
 852   3                      }
 853   2      
 854   2                      /*进入下一流程*/
 855   2                      if(b_ctrl_cnt>=b_i)
 856   2                      {
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 15  

 857   3                              b_wendu_ok=2;
 858   3                      }
 859   2      
 860   2                      /*前5秒前超过150℃的,直接跳下一流程*/
 861   2                      if(b_ctrl_cnt==0 && b_ctrl_sec_1<5)
 862   2                      {
 863   3                              if(gb_wendu>150)
 864   3                              {
 865   4                                      b_wendu_ok=2;
 866   4                              }
 867   3                      }
 868   2              }
 869   1              else if(b_wendu_ok>=2)
 870   1              {
 871   2                      if (gb_wendu < b_set_wendu-50)
 872   2                      {
 873   3                              f_jdq=1;
 874   3                              b_kkg_buf=0;
 875   3                              b_ctrl_sec_2=10;        //下一流程先关
 876   3                              b_wendu_ok=3;
 877   3                      }
 878   2                      else if(gb_wendu < b_set_wendu-10)      //20
 879   2                      {
 880   3                              b_kkg_buf=0;
 881   3                              intermittent(10,22);    //间歇性加热
 882   3                              b_wendu_ok=4;
 883   3                      }               
 884   2                      else
 885   2                      {
 886   3                              if(gb_wendu>=b_set_wendu)
 887   3                              {
 888   4                                      f_jdq=0;
 889   4                                      b_kkg_buf=0;
 890   4                                      b_wendu_ok=6;
 891   4                              }
 892   3                              else
 893   3                              {
 894   4                                      f_jdq=0;
 895   4                                      b_kkg_buf=((b_set_wendu-gb_wendu))*3;
 896   4                                      b_wendu_ok=5;
 897   4                              }                                       
 898   3                      }                       
 899   2              }
 900   1      
 901   1      }
 902          
 903          
 904          
 905          
 906          
 907          /*炖煮*/
 908          void    zhu_mode_dunzhu()       
 909          {
 910   1              f_dingshi_begin=1;
 911   1      
 912   1              //f_dingshi_begin=1;
 913   1              /*计时*/
 914   1          if(b_ctrl_sec_1>=200)
 915   1          {
 916   2              b_ctrl_sec_1=200;
 917   2          }
 918   1      
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 16  

 919   1      
 920   1              /*前118s,开10停8*/
 921   1              /*后面开7停11*/
 922   1              if(b_ctrl_sec_1<112)
 923   1              {
 924   2                      intermittent(10,18);    //间歇性加热
 925   2              }
 926   1              else
 927   1              {
 928   2                      intermittent(7,18);     //间歇性加热
 929   2              }
 930   1      }
 931          
 932          
 933          
 934          
 935          
 936          /*清蒸*/
 937          void    zhu_mode_qingzheng()
 938          {
 939   1          uint temp=0;
 940   1              f_dingshi_begin=1;
 941   1              /*计时*/
 942   1          if(b_ctrl_sec_1>=60)
 943   1          {
 944   2              b_ctrl_sec_1=0;
 945   2                      if(b_ctrl_cnt<255)
 946   2                      b_ctrl_cnt++;
 947   2          }
 948   1      
 949   1              temp=b_ctrl_cnt*60+b_ctrl_sec_1;
 950   1      
 951   1              /*前112s,开10停8*/
 952   1              /*后全功率3分10s*/
 953   1              /*之后开7停11*/
 954   1              if(temp<112)
 955   1              {
 956   2                      intermittent(10,18);    //间歇性加热
 957   2              }
 958   1              else if(temp<302)
 959   1              {
 960   2                      intermittent(18,18);    //间歇性加热
 961   2              }
 962   1              else
 963   1              {
 964   2                      intermittent(7,18);     //间歇性加热
 965   2              }
 966   1      }
 967          
 968          /*慢炖,*/
 969          void    zhu_mode_mandun()       
 970          {
 971   1              
 972   1          uint temp=0;
 973   1              f_dingshi_begin=1;
 974   1              /*计时*/
 975   1          if(b_ctrl_sec_1>=60)
 976   1          {
 977   2              b_ctrl_sec_1=0;
 978   2                      if(b_ctrl_cnt<255)
 979   2                      b_ctrl_cnt++;
 980   2          }
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 17  

 981   1      
 982   1              temp=b_ctrl_cnt*60+b_ctrl_sec_1;
 983   1      
 984   1              /*前112s,开10停8*/
 985   1              /*112-295,全开*/
 986   1              /*开4停14*/
 987   1              if(temp<112)
 988   1              {
 989   2                      intermittent(10,18);    //间歇性加热
 990   2              }
 991   1              else if(temp<295)
 992   1              {
 993   2                      intermittent(18,18);    //间歇性加热
 994   2              }
 995   1              else
 996   1              {
 997   2                      intermittent(4,18);     //间歇性加热
 998   2              }
 999   1      
1000   1      }       
1001          
1002          
1003          /*牛排*/
1004          void    zhu_mode_niupai()       
1005          {
1006   1              
1007   1          uint temp=0;
1008   1              f_dingshi_begin=1;
1009   1              /*计时*/
1010   1          if(b_ctrl_sec_1>=60)
1011   1          {
1012   2              b_ctrl_sec_1=0;
1013   2                      if(b_ctrl_cnt<255)
1014   2                      b_ctrl_cnt++;
1015   2          }
1016   1      
1017   1              temp=b_ctrl_cnt*60+b_ctrl_sec_1;
1018   1      
1019   1              /*前112s,开10停8*/
1020   1              /*后面开6停6*/
1021   1              if(temp<112)
1022   1              {
1023   2                      intermittent(10,18);    //间歇性加热
1024   2              }
1025   1              else
1026   1              {
1027   2                      intermittent(6,12);     //间歇性加热
1028   2              }
1029   1      
1030   1      }       
1031          
1032          
1033          
1034          
1035          
1036          
1037          /*自动保温*/
1038          void    zhu_mode_bb()
1039          {
1040   1              bit f_out_temp=0;       //1:输出 0:不输出
1041   1      
1042   1              f_dingshi_begin=1;
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 18  

1043   1              //intermittent(2,18);   //间歇性加热
1044   1          if(b_ctrl_sec_1>=60)
1045   1          {
1046   2              b_ctrl_sec_1=0;
1047   2                      if(b_ctrl_cnt<255)
1048   2                      b_ctrl_cnt++;
1049   2          }
1050   1      
1051   1              if(b_set_wendu<100)
1052   1              {
1053   2                      if (gb_wendu < b_set_wendu-5)
1054   2                      {
1055   3                              f_jdq=1;
1056   3                      }
1057   2                      else if (gb_wendu < b_set_wendu)
1058   2                      {
1059   3                              f_jdq=0;
1060   3                              b_kkg_buf=20;
1061   3                      }
1062   2                      else
1063   2                      {
1064   3                              f_jdq=0;
1065   3                              b_kkg_buf=0;
1066   3                      }
1067   2              }
1068   1              else
1069   1              {
1070   2                      //static uchar b_wendu_ok=0;    //达到目标温度的次数
1071   2                      
1072   2                      
1073   2                      if(b_wendu_ok==1)
1074   2                      {
1075   3                              if (gb_wendu < b_set_wendu-80)
1076   3                              {
1077   4                                      f_jdq=1;
1078   4                                      b_kkg_buf=0;
1079   4                                      
1080   4                              }               
1081   3                              else
1082   3                              {
1083   4                                      f_jdq=0;
1084   4                                      b_kkg_buf=((b_set_wendu-gb_wendu)/6);
1085   4      
1086   4                              }
1087   3      
1088   3                              if(gb_wendu>=b_set_wendu)
1089   3                              {
1090   4                                      b_wendu_ok=2;
1091   4                              }
1092   3      
1093   3                              if(b_ctrl_cnt>=2)
1094   3                              {
1095   4                                      b_wendu_ok=2;
1096   4                              }
1097   3                      }
1098   2                      else if(b_wendu_ok>=2)
1099   2                      {
1100   3                              if (gb_wendu < b_set_wendu-50)
1101   3                              {
1102   4                                      f_jdq=1;
1103   4                                      b_kkg_buf=0;
1104   4                                      b_ctrl_sec_2=10;        //下一流程先关
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 19  

1105   4                                      b_wendu_ok=3;
1106   4                              }
1107   3                              else if(gb_wendu < b_set_wendu-10)      //20
1108   3                              {
1109   4                                      b_kkg_buf=0;
1110   4                                      intermittent(10,22);    //间歇性加热
1111   4                                      b_wendu_ok=4;
1112   4                              }               
1113   3                              else
1114   3                              {
1115   4                                      if(gb_wendu>=b_set_wendu)
1116   4                                      {
1117   5                                              f_jdq=0;
1118   5                                              b_kkg_buf=0;
1119   5                                              b_wendu_ok=6;
1120   5                                      }
1121   4                                      else
1122   4                                      {
1123   5                                              f_jdq=0;
1124   5                                              b_kkg_buf=((b_set_wendu-gb_wendu))*3;
1125   5      
1126   5      
1127   5                                              b_wendu_ok=5;
1128   5                                      }                                       
1129   4                              }                       
1130   3                      }
1131   2      
1132   2              }
1133   1      
1134   1      }
1135          
1136          
1137          
1138          
1139          
1140          
1141          /*保温流程处理*/
1142          void    baowen_mode_hdle()
1143          {
1144   1              
1145   1      
1146   1              if(gb_wendu<45)
1147   1              {
1148   2                      f_out_out=1;
1149   2              }
1150   1      
1151   1              if (gb_wendu>55)
1152   1              {
1153   2                      f_out_out=0;
1154   2              }
1155   1      
1156   1      
1157   1              if(f_out_out)
1158   1              {
1159   2                      f_jdq=1;
1160   2              }
1161   1              else
1162   1              {
1163   2                      f_jdq=0;
1164   2              }
1165   1      
1166   1      
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 20  

1167   1      
1168   1      
1169   1              
1170   1      //      /*计时*/
1171   1      //    if(b_ctrl_sec_1>=60)
1172   1      //    {
1173   1      //        b_ctrl_sec_1=0;
1174   1      //              if(b_ctrl_cnt<255)
1175   1      //              b_ctrl_cnt++;
1176   1      //    }
1177   1      //
1178   1      //      /*0-5分钟,开14s关31s*/
1179   1      //      /*5-10分钟,关*/
1180   1      //      /*10分钟后,按照开150s关570s一直循环*/
1181   1      //
1182   1      //      if(b_ctrl_cnt<5)
1183   1      //      {
1184   1      //              intermittent(14,45);    //间歇性加热
1185   1      //
1186   1      //      }
1187   1      //      else if (b_ctrl_cnt>=5 && b_ctrl_cnt<10)
1188   1      //      {
1189   1      //              f_jdq=0;
1190   1      //              b_ctrl_sec_2=0;
1191   1      //      }
1192   1      //      /*开两分半钟,停9分半分钟*/
1193   1      //      /*开150s 关570s*/
1194   1      //      else if(b_ctrl_cnt>=10)
1195   1      //      {
1196   1      //              intermittent(150,720);  //间歇性加热
1197   1      //      }       
1198   1              
1199   1              /*默认保温时间2h*/
1200   1              if(b_baowen_hour>=6)
1201   1          {
1202   2              shutdown_power();
1203   2              open_buz(5);    //工作完成音
1204   2          }
1205   1      }
1206          
1207          
1208          void    zhufan_hdle_ONE()
1209          {
1210   1          f_dingshi_begin = 1;
1211   1          switch(b_ctrl_status)
1212   1          {
1213   2          case 0:
1214   2                      /*计时*/
1215   2              if(b_ctrl_sec_1>=60)
1216   2              {
1217   3                  b_ctrl_sec_1=0;
1218   3                  b_ctrl_cnt++;
1219   3              }
1220   2      
1221   2      
1222   2              if((b_ctrl_cnt >= 5)||(gb_wendu >= 125))
1223   2                  next_step();
1224   2      
1225   2              baowen_hdle(58,60,0x14);
1226   2              break;
1227   2          case 1:
1228   2              next_step();
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 21  

1229   2              break;
1230   2          case 2:
1231   2              next_step();
1232   2              break;
1233   2          case 3:
1234   2                      /*计时*/
1235   2              if(b_ctrl_sec_3>=60)
1236   2              {
1237   3                  b_ctrl_sec_3=0;
1238   3                  b_ctrl_cnt2++;
1239   3              }
1240   2      
1241   2                      /*转下一流程的条件*/
1242   2                      /*1.超过50min后,转下一流程*/
1243   2                      /*2.超过连续120℃,60s进入下一流程*/
1244   2                      /*3.*/
1245   2              if(b_ctrl_cnt2>=50)
1246   2                  next_step();
1247   2              else
1248   2              {
1249   3                  if(gb_wendu>=120)
1250   3                  {
1251   4                      b_ctrl_cnt1=0x01;
1252   4                      if(b_ctrl_cnt>=10)
1253   4                          next_step();
1254   4                      else if(b_ctrl_sec_1>=60)
1255   4                          next_step();
1256   4                  }
1257   3                  else
1258   3                  {
1259   4                      if(b_ctrl_cnt1==0x01)
1260   4                      {
1261   5                          b_ctrl_cnt1=0;
1262   5                          b_ctrl_cnt++;
1263   5                      }
1264   4                      b_ctrl_sec_1=0;
1265   4      
1266   4                      //if(b_ctrl_cnt2>=15)   
1267   4                      //    heat_hdle(0xff);
1268   4                      //else if(b_ctrl_cnt2>=10)
1269   4                      //    heat_hdle(0x20);
1270   4                      //else
1271   4                      //    heat_hdle(0x19);  
1272   4      
1273   4                      if(b_ctrl_cnt2>=15)     
1274   4                          heat_hdle(25);
1275   4                      else if(b_ctrl_cnt2>=10)
1276   4                          heat_hdle(28);
1277   4                      else
1278   4                          heat_hdle(20);      
1279   4      
1280   4                  }
1281   3              }
1282   2              break;
1283   2          case 4:
1284   2              if(gb_wendu <= 105)
1285   2                  b_ctrl_cnt = 0x01;
1286   2              if(b_ctrl_cnt == 0x01)
1287   2              {
1288   3                  if(gb_wendu >= 107)
1289   3                      next_step();
1290   3                  heat_hdle(0x0f);
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 22  

1291   3              }
1292   2              break;
1293   2          case 5:
1294   2              baowen_hdle(100,103,10);//0x0f
1295   2              break;
1296   2          default:
1297   2              shutdown_power();
1298   2              break;
1299   2          }
1300   1      
1301   1      }
1302          
1303          #endif
1304          
1305          
1306          
1307          
1308          
1309          
1310          
1311          
1312          
1313          
1314          
1315          
1316          #if 0 //单探头流程
              
              
              //---------------------酸奶----------------------
              void    suannai_hdle_ONE()
              {
                  f_dingshi_begin = 1;
                  three_heat(gb_wendu,0x14,30,0x0a,35,0x05,40,0x00);
              }
              
              
              //---------------------单探头炖汤----------------------
              void    dun_hdle_ONE()
              {
                  f_dingshi_begin = 1;
                  three_heat(gb_wendu,0xff,85,0x1e,90,0x0f,95,0x05);
              }
              
              
              //---------------------蒸,隔水炖----------------------
              void    zheng_hdle_ONE()
              {
                  f_dingshi_begin = 1;
                  if(gb_wendu >= 95)
                  {
                      heat_hdle(0x0f);
                  }
                  else
                  {
                      heat_hdle(0xff);
                  }
              }
              
              //---------------------单探头煲汤----------------------
              void    tang_hdle_ONE()
              {
                  f_dingshi_begin = 1;
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 23  

                  three_heat(gb_wendu,0xff,85,0x1e,90,0x14,95,0x0a);
              }
              
              //---------------------单探头煮粥/稀饭----------------------
              void    zhuzhou_hdle_ONE()
              {
                  uchar       b_tmp=0;
                  f_dingshi_begin = 1;
              
                  switch(b_ctrl_status)
                  {
                  case 0:
                      if(gb_wendu <= 90)
                          next_step();
                      break;
                  case 1:
                      if(b_ctrl_sec_3>=60)
                      {
                          b_ctrl_sec_3=0;
                          b_ctrl_cnt2++;
                      }
                      if(b_ctrl_cnt2>=50)
                          next_step();
                      else
                      {
                          b_tmp = 93; //设定温度
              
                          if(gb_wendu < b_wendu_min)
                              b_wendu_min = gb_wendu;
              
                          if((b_ctrl_cnt==0)||(!f_power_power))
                              b_wendu_min = 255;
              
                          if((!f_power_power)&&(gb_wendu>b_tmp))
                              b_ctrl_cnt |= 0x01;
              
                          if((b_ctrl_cnt!=0)&&(f_power_power)&&(gb_wendu>b_tmp+1))
                          {
                              if(b_wendu_min<255)
                              {
                                  if(b_tmp<b_wendu_min+3)
                                      next_step();
                              }
                          }
                          if(b_wendu_min>b_tmp-3)
                              baowen_hdle(b_tmp,b_tmp+2,0xff);
                          else
                              baowen_hdle(b_tmp,b_tmp+5,0xff);
              
                          if((!f_power_power)||(gb_wendu<b_tmp+2))
                              b_ctrl_sec_1=0;
              
                          if(b_ctrl_sec_1>120)
                              f_power_power=0;
                      }
                      break;
                  case 2:
                      b_tmp=150;
                      b_tmp+=b_ctrl_cnt*8;
                      if(b_tmp>=177)
                          b_tmp=177;
              
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 24  

                      if(b_ctrl_sec_1>=210)
                      {
                          b_ctrl_sec_1=0;
                          b_ctrl_cnt++;
                      }
                      if(b_ctrl_sec_1>=b_tmp)
                          f_jdq=1;
                      break;
                  default:
                      break;
              
                  }
              }
              
              
              
              //---------------------单探头煮饭----------------------
              void    zhufan_hdle_ONE()
              {
                  f_dingshi_begin = 1;
                  switch(b_ctrl_status)
                  {
                  case 0:
                      if(b_ctrl_sec_1>=60)
                      {
                          b_ctrl_sec_1=0;
                          b_ctrl_cnt++;
                      }
                      if((b_ctrl_cnt >= 5)||(gb_wendu >= 125))
                          next_step();
              
                      baowen_hdle(58,60,0x14);
                      break;
                  case 1:
                      next_step();
                      break;
                  case 2:
                      next_step();
                      break;
                  case 3:
                      if(b_ctrl_sec_3>=60)
                      {
                          b_ctrl_sec_3=0;
                          b_ctrl_cnt2++;
                      }
                      if(b_ctrl_cnt2>=50)
                          next_step();
                      else
                      {
                          if(gb_wendu>=120)
                          {
                              b_ctrl_cnt1=0x01;
                              if(b_ctrl_cnt>=10)
                                  next_step();
                              else if(b_ctrl_sec_1>=60)
                                  next_step();
                          }
                          else
                          {
                              if(b_ctrl_cnt1==0x01)
                              {
                                  b_ctrl_cnt1=0;
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 25  

                                  b_ctrl_cnt++;
                              }
                              b_ctrl_sec_1=0;
              
                              if(b_ctrl_cnt2>=15)
                                  heat_hdle(0xff);
                              else if(b_ctrl_cnt2>=10)
                                  heat_hdle(0x20);
                              else
                                  heat_hdle(0x19);
                          }
                      }
                      break;
                  case 4:
                      if(gb_wendu <= 105)
                          b_ctrl_cnt = 0x01;
                      if(b_ctrl_cnt == 0x01)
                      {
                          if(gb_wendu >= 107)
                              next_step();
                          heat_hdle(0x0f);
                      }
                      break;
                  case 5:
                      baowen_hdle(100,103,0x0f);
                      break;
                  default:
                      shutdown_power();
                      break;
                  }
              
              }
              
              
              
              //---------------------蛋糕----------------------
              void    dangao_hdle_ONE()
              {
                  f_dingshi_begin=1;
                  if(gb_wendu >= 80)
                      baowen_hdle(129,130,0x0f);
                  else
                      heat_hdle(0xff);
              }
              
              
              //---------------------热饭----------------------
              void    refan_hdle_ONE()
              {
                  f_dingshi_begin=1;
                  if(gb_wendu >= 80)
                      baowen_hdle(105,110,0x14);
                  else
                      heat_hdle(0xff);
              }
              
              
              #endif
1535          
1536          
1537          
1538          
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 26  

1539          
1540          
1541          
1542          
1543          
1544          
1545          #if 0   //需要双探头的流程
              
              //---------------------双探头蒸----------------------
              void    zheng_hdle_TWO()
              {
                  f_dingshi_begin=1;
                  three_heat(gb_wendu2,0xff,60,0x14,95,0x0f,98,0x0a);
              }
              
              
              
              //---------------------双探头煮粥----------------------
              void    zhuzhou_hdle_TWO()
              {
                  f_dingshi_begin=1;
                  switch(b_ctrl_status)
                  {
                  case 0:
                      if(gb_wendu < 110)
                          heat_hdle(0xff);
                      if(gb_wendu2 >= 80)
                          next_step();
                      break;
                  case 1:
                      heat_hdle(0x14);
              
                      if(gb_wendu2 >= 90)
                          next_step();
                      break;
                  case 2:
                      three_heat(gb_wendu2,0x0f,90,0x08,95,0x05,99,0x03);
                      break;
                  default:
                      shutdown_power();
                      break;
                  }
              }
              
              
              //---------------------双探头煲汤----------------------
              void    tang_hdle_TWO()
              {
                  f_dingshi_begin=1;
                  switch(b_ctrl_status)
                  {
                  case 0:
                      next_step();
                      break;
                  case 1:
                      if(gb_wendu2>=80)
                          next_step();
                      baowen_hdle(105,110,0xff);
                      break;
                  case 2:
                      three_heat(gb_wendu2,0x14,90,0x0f,95,0x0a,99,0x06);
                      break;
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 27  

                  default:
                      shutdown_power();
                      break;
                  }
              }
              
              //---------------------双探头糖水----------------------
              void    tangshui_hdle_TWO()
              {
                  f_dingshi_begin=1;
                  switch(b_ctrl_status)
                  {
                  case 0:
                      next_step();
                      break;
                  case 1:
                      if((b_ctrl_cnt>=20)||(gb_wendu2>=80))
                          next_step();
                      baowen_hdle(100,105,0x20);
                      break;
                  case 2:
                      three_heat(gb_wendu2,0x0f,90,0x0c,95,0x0a,99,0x08);
                      break;
                  default:
                      shutdown_power();
                      break;
                  }
              }
              
              //---------------------双探头煮饭----------------------
              void    zhufan_hdle_TWO()
              {
              //              f_dingshi_begin=1;
                  switch(b_ctrl_status)
                  {
                  case 0:
                      if(b_mode==0x02)
                          next_step();
              
                      if(b_ctrl_sec_1>=60)
                      {
                          b_ctrl_sec_1=0;
                          b_ctrl_cnt++;
                      }
                      if((b_ctrl_cnt>=7)||(gb_wendu>=120))
                          next_step();
                      baowen_hdle(58,60,0x20);
                      break;
                  case 1:
                      if(gb_wendu >= 130)
                          next_step();
                      else if(gb_wendu2 >= 80)
                          next_step();
                      heat_hdle(0xff);
                      break;
                  case 2:
                      if(gb_wendu >= 130)
                          next_step();
                      heat_hdle(0xff);
                      gaoyuan_heat(95);
                      break;
                  case 3:
C51 COMPILER V9.60.0.0   WORK_DEAL                                                         05/09/2023 16:57:25 PAGE 28  

                      if(gb_wendu<=115)
                          next_step();
                      break;
                  case 4:
                      if(gb_wendu>=116)
                          next_step();
                      heat_hdle(0x19);
                      break;
                  case 5:
                      next_step();
                      break;
                  case 6:
                      next_step();
                      break;
                  case 7:
                      f_dingshi_begin = 1;
                      baowen_hdle(103,105,0x0a);
                      break;
                  default:
                      shutdown_power();
                      break;
                  }
              }
              
              #endif
1688          
1689          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2207    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     37    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     19       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
