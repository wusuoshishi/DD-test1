C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Output\Key.obj
COMPILER INVOKED BY: D:\Program_Files\KEIL5_521A\C51\BIN\C51.EXE Application_Library\Key.c OMF2 OPTIMIZE(8,SPEED) BROWSE
                    - INCDIR(.\Inc;.\User;.\Application_Library;.\Project) DEBUG PRINT(.\List\Key.lst) OBJECT(.\Output\Key.obj)

line level    source

   1          #include        "..\Project\Project.h"
   2          #include        "..\Application_Library\Global.h"
   3          #include <intrins.h>
   4          
   5          
   6          
   7          #if     c_key_mode
              unsigned        char                    keysFlagQC=0;
              #endif
  10          
  11          unsigned char   xdata   b_key_value=0;
  12          unsigned char   xdata   b_key_double=0;
  13          unsigned char   xdata   b_key_old=0;
  14          unsigned char   xdata   b_key_num=0;
  15          unsigned char   xdata   b_key_cnt=0;    //按下消抖
  16          unsigned char   xdata   b_key_noCnt=0;  //释放消抖
  17          unsigned char   xdata   b_key_longcnt=0;
  18          
  19          uchar   xdata   Target_wendu_mode_1=0;  //左目标温度灯 0:无,1:80℃，2:100℃，3:120℃
  20          uchar   xdata   Target_wendu_mode_2=0;  //左目标温度灯 0:无,1:80℃，2:100℃，3:120℃
  21          uchar   xdata   set_time_1_hour=0; //左定时灯
  22          uchar   xdata   set_time_1_min=0;  //
  23          uchar   xdata   set_time_1_sec=0;  //
  24          uchar   xdata   set_time_2_hour=0; //右定时灯
  25          uchar   xdata   set_time_2_min=0;  //
  26          uchar   xdata   set_time_2_sec=0;  //
  27          
  28          uchar   xdata   b_stop_1_sec=0;  //左暂停时间
  29          uchar   xdata   b_stop_1_min=0;  //左暂停时间
  30          uchar   xdata   b_stop_2_sec=0;  //右暂停时间
  31          uchar   xdata   b_stop_2_min=0;  //右暂停时间
  32          
  33          
  34          uchar   xdata   b_force_flash_cnt=0;    //强制闪烁计数
  35          bit     f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
  36          uchar   xdata   b_clock_key =0; //运行过程中,无按键按下,1s后锁键
  37          
  38          
  39          bit             f_readKey_over=0;
  40          bit             f_longKey=0;
  41          bit             f_firstKey=0;
  42          bit             f_key_done=0;
  43          bit             f_lamp_long=0;
  44          bit             f_power_long=0;
  45          bit             f_key_double=0;
  46          
  47          
  48          
  49          bit   f_k1_down=0;
  50          
  51          typedef struct
  52          {
  53              unsigned char       hour_int;       //小时初始值
  54              unsigned char       min_int;        //分钟初始值
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 2   

  55              unsigned char       hour_max;       //最大小时
  56              unsigned char       min_max;        //最大分钟
  57              unsigned char       hour_min;       //最小小时
  58              unsigned char       min_min;        //最小分钟
  59              unsigned char       chg_num;        //递增分钟数
  60                  unsigned char   chg_num_1;      //递减分钟数
  61                  unsigned char   grade_int;      //档位
  62                  unsigned char   grade_max;      //最大档位
  63                  unsigned char   grade_min;      //最小档位
  64          
  65          
  66          } str_setscan;
  67          
  68          
  69          str_setscan             const   code    tab_set[]=
  70          {
  71                  //初始时间  /最大时间 /最小时间   /递进   /档位
  72              {1, 0,   1, 0,        1, 0,     5, 1,       3,5,1}, //功能1 爆炒 档位可调           
  73              {0, 5,   1, 0,        0, 5,     5, 1,       1,1,1}, //功能2 炖煮 时间可调            
  74              {0, 5,   1, 0,        0, 5,     5, 1,       1,1,1}, //功能3 清蒸 时间可调            
  75              {0,20,   3, 0,        0, 5,    20, 5,       1,1,1},  //功能4 慢炖 时间可调           
  76                  {3,30 ,  60, 0,   1, 0,    30,30,       1,1,1},  //功能5 牛排 时间可调 这个比较特殊,
  77                  {1, 0,   1, 0,    1, 0,     5, 1,       5,5,1}  //功能6 火锅 档位可调            
  78          };
  79          
  80          ////测试
  81          //str_setscan           const   code    tab_set[]=
  82          //{
  83          //      //初始时间/最大时间/最小时间/递进/档位
  84          //    {0,20,    1, 0,     0,15,    5,   5,5,1}, //功能1 蒸煮 时间可调
  85          //    {0,30,    1,10,     0,15,    5,   5,5,1}, //功能2 煎炒 档位可调
  86          //    {0,30,    0,30,     0,30,    5,   1,1,1}, //功能3 煮饭 不可调
  87          //    {0,2,    1,30,      0,15,    5,   5,5,1}  //功能4 焖煮 时间可调
  88          //};
  89          
  90          
  91          
  92          void    key_deal();             //按键处理,20MS执行一次
  93          void    key_scan();             //按键检测
  94          
  95          void    mode_key();             //模式键
  96          void    add_key();              //加键
  97          void    dec_key();              //减键
  98          void    baowen_yuyu_key();      //保温预约按钮(大多数保温预约按钮都会在同一个按键之上)
  99          
 100          void    mode_init();    //功能模式初始化
 101          
 102          
 103          void    dingshi_add_fun();      //定时时间加功能
 104          void    dingshi_dec_fun();      //定时时间减功能
 105          void    baowen_add_fun();       //保温时间加功能
 106          void    baowen_dec_fun();       //保温时间减功能
 107          
 108          void    yuyue_add_fun();        //预约时间加功能
 109          void    yuyue_dec_fun();        //预约时间减功能
 110          void    grade_add_fun();        //档位加功能
 111          void    grade_dec_fun();        //档位减功能
 112          void    baowen_fun();           //保温功能
 113          
 114          void    quit_work();    //退出工作
 115          void    action_work();  //开始工作
 116          void    key_clr_sec();  //刷新显示并且响蜂鸣器
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 3   

 117          /*-----------------------------------------------------------------
 118          函数名称： void baowen_yuyu_key(void)
 119          函数功能： 保温预约按钮
 120          输入参数： 无
 121          返 回 值： 无
 122          说明:大多数保温预约按钮都会在同一个按键之上
 123          -----------------------------------------------------------------*/
 124          void    baowen_yuyu_key()
 125          {
 126   1              baowen_fun();
 127   1      }
 128          
 129          
 130          #if     c_key_mode
              //轻触按键将此两个函数插入显示扫描中
              
              //  按键置输入
              void  sw_scan_in()
              {
                  key_input;
                  key_pull;
              }
              
              //  按键检测
              void  sw_scan()
              {
                  keysFlagQC = 0;
                  if(!p_k1)
                      keysFlagQC = 1;
                  if(!p_k2)
                      keysFlagQC = 2;
                  //if(!p_k3)
                  //    keysFlagQC = 3;
                  //if(!p_k4)
                  //    keysFlagQC = 4;
                  //if(!p_k5)
                  //    keysFlagQC = 5;
                  //if(!p_k6)
                  //    keysFlagQC = 6;
                  //if(!p_k7)
                  //    keysFlagQC = 7;
                  //if(!p_k8)
                  //    keysFlagQC = 8;
                  key_output;
              }
              #endif
 163          
 164          
 165          
 166          /*-----------------------------------------------------------------
 167          函数名称： void key_scan(void)
 168          函数功能： 按键检测
 169          输入参数： 无
 170          返 回 值： 无
 171          -----------------------------------------------------------------*/
 172          void    key_scan()
 173          {
 174   1      
 175   1          uchar i=0;
 176   1      
 177   1      #if     c_key_mode
              
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 4   

              #pragma message "轻触按键"
                  b_key_value = keysFlagQC;
              
              #else
 183   1      
 184   1      #pragma message "触摸按键"
*** MESSAGE C286 IN LINE 184 OF Application_Library\Key.c: 触摸按键
 185   1      
 186   1          b_key_value=0;
 187   1          for(i = 0; i < SNS_NUM; i++)
 188   1          {
 189   2              if((keys_flag) & (((ulong)0x01)<<SNS[i]))
 190   2              {
 191   3                  b_key_value = i;
 192   3                  b_key_value++;
 193   3                  b_disp_test=b_key_value;
 194   3              }
 195   2          }
 196   1      
 197   1      #endif
 198   1      
 199   1          if(b_key_value)
 200   1          {
 201   2              b_key_noCnt=0;
 202   2              if(b_key_value==b_key_old)
 203   2              {
 204   3                  b_key_cnt++;
 205   3                  if(b_key_cnt>=c_shortKey_cnt)
 206   3                  {
 207   4                      b_key_cnt=0;
 208   4                      if(f_readKey_over==0)
 209   4                      {
 210   5                          f_readKey_over=1;
 211   5                          f_key_done=1;
 212   5                      }
 213   4                  }
 214   3              }
 215   2              else
 216   2              {
 217   3                  b_key_old=b_key_value;
 218   3                  b_key_cnt=0;
 219   3              }
 220   2          }
 221   1          //无按键
 222   1          else
 223   1          {
 224   2      
 225   2              b_key_cnt=0;
 226   2              b_key_noCnt++;
 227   2              if(b_key_noCnt>=1)
 228   2              {
 229   3                  b_key_value=0;
 230   3                  b_key_noCnt=0;
 231   3                  f_readKey_over=0;
 232   3                  f_firstKey=0;
 233   3                  b_key_longcnt=0;
 234   3                  b_key_old=0;
 235   3                  /*-----------------------------此处复用按键----------------------------*/
 236   3                  //if(f_k1_down)
 237   3                  //{
 238   3                  //  f_k1_down=0;
 239   3                  //  if(b_mode!=2)
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 5   

 240   3                  //  {
 241   3                  //    b_mode=2;
 242   3                  //    mode_key();
 243   3                  //    f_disp_dingshi=1;
 244   3                  //    key_clr_sec();
 245   3                  //    open_buz(1);
 246   3                  //  }
 247   3                  //}
 248   3                  /*--------------------------------------------------------------------*/
 249   3              }
 250   2          }
 251   1      
 252   1      }
 253          
 254          /*-----------------------------------------------------------------
 255          函数名称： void yuyue_add_fun(void)
 256          函数功能： 预约时间加
 257          输入参数： 无
 258          返 回 值： 无
 259          -----------------------------------------------------------------*/
 260          void    yuyue_add_fun()
 261          {
 262   1              b_yuyue_sec=0;
 263   1      
 264   1              b_yuyue_min+=30;
 265   1      
 266   1              if(b_yuyue_hour >=24 && b_yuyue_min >0)
 267   1              {
 268   2                      b_yuyue_hour=24;
 269   2                      b_yuyue_min=0;
 270   2              }
 271   1              else
 272   1              {
 273   2                      if(b_yuyue_min>=60)
 274   2                      {
 275   3                              b_yuyue_min=0;
 276   3                              b_yuyue_hour++;
 277   3                              if(b_yuyue_hour >=24)
 278   3                              {
 279   4                                      b_yuyue_hour=24;        
 280   4                              }
 281   3                      }
 282   2              }
 283   1      
 284   1      
 285   1      
 286   1      
 287   1      }
 288          
 289          
 290          /*-----------------------------------------------------------------
 291          函数名称： void yuyue_dec_fun(void)
 292          函数功能： 预约时间减
 293          输入参数： 无
 294          返 回 值： 无
 295          -----------------------------------------------------------------*/
 296          void    yuyue_dec_fun()
 297          {
 298   1              //b_yuyue_min=0;
 299   1      //
 300   1          //if(b_yuyue_hour>1)        //最小值为1
 301   1          //  b_yuyue_hour--;
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 6   

 302   1      
 303   1      
 304   1      
 305   1              
 306   1              b_yuyue_sec=0;  
 307   1      
 308   1              if(b_yuyue_hour>=1)
 309   1              {
 310   2                      if(b_yuyue_min>=30)
 311   2                              b_yuyue_min-=30;
 312   2                      else
 313   2                      {
 314   3                              b_yuyue_hour--;
 315   3                              b_yuyue_min=60+b_yuyue_min-30;
 316   3                      }
 317   2              }
 318   1      
 319   1      
 320   1      
 321   1      }
 322          
 323          
 324          
 325          
 326          /*-----------------------------------------------------------------
 327          函数名称： void mode_init(void)
 328          函数功能： 功能模式初始化
 329          输入参数： 无
 330          返 回 值： 无
 331          -----------------------------------------------------------------*/
 332          void mode_init()
 333          {
 334   1              b_mode=1;
 335   1              /*获取默认时间*/
 336   1              b_dingshi_hour = tab_set[b_mode-1].hour_int;
 337   1          b_dingshi_min  = tab_set[b_mode-1].min_int;
 338   1      
 339   1      
 340   1              /*获取默认档位*/
 341   1              b_grade=tab_set[b_mode-1].grade_int;
 342   1      
 343   1              /*设置对应的状态*/
 344   1              f_mjs_set=1;
 345   1              f_mjs_dingshi=1;
 346   1              //f_mjs_power;
 347   1              //f_mjs_yuyue;
 348   1              //f_mjs_down;
 349   1              //f_dingshi_begin;
 350   1      
 351   1              //f_disp_dingshi=0;
 352   1              //f_disp_yuyue=0;
 353   1      
 354   1              //时间闪3秒
 355   1              b_time_grade_cnt =7     ;       //0:档位,5:时间
 356   1      }
 357          
 358          
 359          /*-----------------------------------------------------------------
 360          函数名称： void baowen_fun(void)
 361          函数功能： 保温功能
 362          输入参数： 无
 363          返 回 值： 无
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 7   

 364          -----------------------------------------------------------------*/
 365          void    baowen_fun()
 366          {
 367   1      
 368   1              f_mjs_set=1;
 369   1              f_mjs_dingshi=1;
 370   1              //f_mjs_power=0;
 371   1              //f_mjs_yuyue=0;
 372   1      
 373   1              f_dingshi_begin=1;
 374   1      
 375   1              b_mode  |= 0x80;
 376   1              
 377   1              /*设置默认时间*/
 378   1              b_dingshi_hour=24;
 379   1              b_dingshi_min=0;
 380   1              b_dingshi_sec=0;
 381   1      
 382   1              /*设置默认温度*/
 383   1              b_set_wendu=60; //60℃
 384   1      
 385   1      
 386   1      
 387   1      
 388   1      
 389   1              ///*设置默认时间*/
 390   1              ////默认6个小时
 391   1              //b_baowen_hour=6;
 392   1              //b_baowen_min=0;
 393   1              //b_baowen_sec=0;
 394   1              //action_work();
 395   1      }
 396          
 397          
 398          /*-----------------------------------------------------------------
 399          函数名称： void dingshi_add_fun(void)
 400          函数功能： 定时时间加功能
 401          输入参数： 无
 402          返 回 值： 无
 403          -----------------------------------------------------------------*/
 404          void    dingshi_add_fun()
 405          {
 406   1              uchar   i=0;
 407   1      
 408   1              ////显示时间,时间闪3秒
 409   1              //b_time_grade_cnt=7;//;0:档位,5:时间
 410   1      
 411   1      
 412   1      
 413   1              
 414   1              /*获取每次递进的时间*/
 415   1          if(b_key_longcnt==0)
 416   1              i=tab_set[b_mode-1].chg_num;
 417   1          else
 418   1              i=tab_set[b_mode-1].chg_num;
 419   1      
 420   1      
 421   1                      /*现在值和最大值进行比较*/
 422   1              if((b_dingshi_hour*60+b_dingshi_min)>=(tab_set[b_mode-1].hour_max*60+tab_set[b_mode-1].min_max))
 423   1              {
 424   2                              /*大于等于最大值,赋值最大值*/
 425   2                  key_clr_sec();
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 8   

 426   2                  b_dingshi_hour=tab_set[b_mode-1].hour_max;
 427   2                  b_dingshi_min=tab_set[b_mode-1].min_max;
 428   2              }
 429   1              else
 430   1              {
 431   2                              /*加时间,然后进行范围判断*/
 432   2                      key_clr_sec();
 433   2                  b_dingshi_min+=i;
 434   2                  if(b_dingshi_min>=60)
 435   2                  {
 436   3                      b_dingshi_min-=60;
 437   3                      b_dingshi_hour++;
 438   3                  }
 439   2                              /*现在值和最大值进行比较*/
 440   2                  if((b_dingshi_hour*60+b_dingshi_min)>=(tab_set[b_mode-1].hour_max*60+tab_set[b_mode-1].min_max))
 441   2                  {
 442   3                                      /*大于等于最大值,赋值最大值*/
 443   3                      key_clr_sec();
 444   3                      b_dingshi_hour=tab_set[b_mode-1].hour_max;
 445   3                      b_dingshi_min=tab_set[b_mode-1].min_max;
 446   3                  }
 447   2              }
 448   1      
 449   1      }
 450          
 451          
 452          /*-----------------------------------------------------------------
 453          函数名称： void baowen_add_fun(void)
 454          函数功能： 保温时间加功能
 455          输入参数： 无
 456          返 回 值： 无
 457          -----------------------------------------------------------------*/
 458          void    baowen_add_fun()
 459          {
 460   1              uchar   i=0;
 461   1              b_dingshi_sec=0;
 462   1              i=30;
 463   1              key_clr_sec();
 464   1      
 465   1              /*现在值和最大值进行比较*/
 466   1          if((b_dingshi_hour*60+b_dingshi_min)>=(24*60+0))
 467   1          {
 468   2                      /*大于等于最大值,赋值最大值*/
 469   2              b_dingshi_hour=24;
 470   2              b_dingshi_min=0;
 471   2          }
 472   1          else
 473   1          {
 474   2                      /*加时间,然后进行范围判断*/
 475   2              b_dingshi_min+=i;
 476   2              if(b_dingshi_min>=60)
 477   2              {
 478   3                  b_dingshi_min-=60;
 479   3                  b_dingshi_hour++;
 480   3              }
 481   2                      /*现在值和最大值进行比较*/
 482   2              if((b_dingshi_hour*60+b_dingshi_min)>=(24*60+0))
 483   2              {
 484   3                                              /*大于等于最大值,赋值最大值*/
 485   3                  b_dingshi_hour=24;
 486   3                  b_dingshi_min=0;
 487   3              }
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 9   

 488   2          }
 489   1      
 490   1      }
 491          
 492          
 493          
 494          
 495          
 496          
 497          /*-----------------------------------------------------------------
 498          函数名称： void dingshi_dec_fun(void)
 499          函数功能： 定时时间减
 500          输入参数： 无
 501          返 回 值： 无
 502          -----------------------------------------------------------------*/
 503          void    dingshi_dec_fun()
 504          {
 505   1              uchar   i=0;
 506   1              ////显示时间,时间闪3秒
 507   1              //b_time_grade_cnt=7;//;0:档位,5:时间
 508   1      
 509   1      
 510   1              //获取每次递进的时间
 511   1          if(b_key_longcnt==0)
 512   1              i=tab_set[b_mode-1].chg_num_1;
 513   1          else
 514   1              i=tab_set[b_mode-1].chg_num_1;
 515   1      
 516   1          key_clr_sec();      //刷新显示并且响蜂鸣器
 517   1      
 518   1          if((b_dingshi_hour*60+b_dingshi_min)>=i)    //判断能不能减的下
 519   1          {
 520   2              if((b_dingshi_hour*60+b_dingshi_min)<=(tab_set[b_mode-1].hour_min*60+tab_set[b_mode-1].min_min))
 521   2              {
 522   3                  b_dingshi_hour=tab_set[b_mode-1].hour_min;
 523   3                  b_dingshi_min=tab_set[b_mode-1].min_min;
 524   3              }
 525   2              else
 526   2              {
 527   3                      if(b_dingshi_min<i)
 528   3                      {
 529   4                              b_dingshi_min+=60;
 530   4                          b_dingshi_hour--;
 531   4                      }
 532   3                  b_dingshi_min-=i;
 533   3                  if((b_dingshi_hour*60+b_dingshi_min)<(tab_set[b_mode-1].hour_min*60+tab_set[b_mode-1].min_min)
             -)
 534   3                  {
 535   4                      b_dingshi_hour=tab_set[b_mode-1].hour_min;
 536   4                      b_dingshi_min=tab_set[b_mode-1].min_min;
 537   4                  }
 538   3              }
 539   2          }
 540   1              /*不够减,直接赋值之值*/
 541   1          else
 542   1          {
 543   2              b_dingshi_hour=tab_set[b_mode-1].hour_min;
 544   2              b_dingshi_min=tab_set[b_mode-1].min_min;
 545   2          }
 546   1      
 547   1      }
 548          
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 10  

 549          
 550          /*-----------------------------------------------------------------
 551          函数名称： void baowen_dec_fun(void)
 552          函数功能： 保温时间减
 553          输入参数： 无
 554          返 回 值： 无
 555          -----------------------------------------------------------------*/
 556          void    baowen_dec_fun()
 557          {
 558   1              uchar   i=0;
 559   1              ////显示时间,时间闪3秒
 560   1              //b_time_grade_cnt=7;//;0:档位,5:时间
 561   1              b_dingshi_sec=0;
 562   1              
 563   1              //获取每次递进的时间
 564   1          i=30;
 565   1      
 566   1          key_clr_sec();      //刷新显示并且响蜂鸣器
 567   1      
 568   1          if((b_dingshi_hour*60+b_dingshi_min)>=i)    //判断能不能减的下
 569   1          {
 570   2              if((b_dingshi_hour*60+b_dingshi_min)<=(0))
 571   2              {
 572   3                  b_dingshi_hour=0;
 573   3                  b_dingshi_min=0;
 574   3              }
 575   2              else
 576   2              {
 577   3                      if(b_dingshi_min<i)
 578   3                      {
 579   4                              b_dingshi_min+=60;
 580   4                          b_dingshi_hour--;
 581   4                      }
 582   3                  b_dingshi_min-=i;
 583   3                  if((b_dingshi_hour*60+b_dingshi_min)<(0))
 584   3                  {
 585   4                      b_dingshi_hour=0;
 586   4                      b_dingshi_min=0;
 587   4                  }
 588   3              }
 589   2          }
 590   1              /*不够减,直接赋值之值*/
 591   1          else
 592   1          {
 593   2              b_dingshi_hour=0;
 594   2              b_dingshi_min=0;
 595   2          }
 596   1      
 597   1      }
 598          
 599          
 600          
 601          /*-----------------------------------------------------------------
 602          函数名称： void grade_dec_fun(void)
 603          函数功能： 档位减功能
 604          输入参数： 无
 605          返 回 值： 无
 606          -----------------------------------------------------------------*/
 607          void    grade_dec_fun()
 608          {
 609   1      
 610   1      
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 11  

 611   1              b_time_grade_cnt=0;//;0:档位,5:时间
 612   1      
 613   1      
 614   1              #if 1 //不可循环
 615   1                      if(b_grade>tab_set[b_mode-1].grade_min)
 616   1                              b_grade--;
 617   1              #endif
 618   1      
 619   1              #if 0 //可循环
                              b_grade--;
                              /*达到最小值->最大值*/
                              if(b_grade<tab_set[b_mode-1].grade_min)
                                      b_grade=tab_set[b_mode-1].grade_max;
                      #endif
 625   1      
 626   1      
 627   1      
 628   1              /*运行之后按下,就不会自动降档*/
 629   1              if(f_mjs_power)
 630   1                      f_NO_jiangdang=1;       //降档标志位 0:可降档 1:不可降档
 631   1      
 632   1      }
 633          
 634          
 635          /*-----------------------------------------------------------------
 636          函数名称： void grade_add_fun(void)
 637          函数功能： 档位加功能
 638          输入参数： 无
 639          返 回 值： 无
 640          -----------------------------------------------------------------*/
 641          void    grade_add_fun()
 642          {
 643   1              //b_time_grade_cnt=0;//;0:档位,5:时间
 644   1      
 645   1              #if 1 //不可以循环
 646   1              if (b_grade<tab_set[b_mode-1].grade_max)
 647   1              {
 648   2                      b_grade++;
 649   2              }
 650   1              #endif
 651   1      
 652   1              #if 0 //可循环
                              b_grade++;
                              /*超过最大值->最小值*/
                              if (b_grade>tab_set[b_mode-1].grade_max)
                                      b_grade=tab_set[b_mode-1].grade_min;
                      #endif 
 658   1      
 659   1      
 660   1              /*运行之后按下,就不会自动降档*/
 661   1              if(f_mjs_power)
 662   1                      f_NO_jiangdang=1;       //降档标志位 0:可降档 1:不可降档
 663   1      
 664   1      }
 665          
 666          
 667          /*-----------------------------------------------------------------
 668          函数名称： void key_yuyue(void)
 669          函数功能： 预约键
 670          输入参数： 无
 671          返 回 值： 无
 672          -----------------------------------------------------------------*/
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 12  

 673          void  key_yuyue()
 674          {
 675   1              /*主状态*/
 676   1          f_mjs_set=1;
 677   1              f_mjs_yuyue=1;
 678   1              
 679   1              /*显示*/
 680   1          f_disp_yuyue=1;
 681   1          f_disp_dingshi=0;
 682   1      
 683   1              /*默认时间*/
 684   1              b_yuyue_sec=0;
 685   1          b_yuyue_min=30;
 686   1          b_yuyue_hour=0;
 687   1      
 688   1      
 689   1      
 690   1      //    if(f_mjs_yuyue)
 691   1      //    {
 692   1      //              //       yuyue_add_fun();
 693   1      //        f_mjs_yuyue=0;
 694   1      //        f_disp_yuyue=0;
 695   1      //        f_disp_dingshi=1;
 696   1      //        if(!b_mode)
 697   1      //        {
 698   1      //            f_mjs_set=0;
 699   1      //            f_disp_dingshi=0;
 700   1      //        }
 701   1      //    }
 702   1      //      /*默认预约时间 30分钟*/
 703   1      //    else
 704   1      //    {
 705   1      //        f_mjs_yuyue=1;
 706   1      //              f_disp_yuyue=1;
 707   1      //              f_disp_dingshi=0;       
 708   1      //
 709   1      //        b_yuyue_min=30;
 710   1      //        b_yuyue_hour=0;
 711   1      //    }
 712   1      
 713   1      
 714   1      
 715   1      
 716   1      
 717   1      }
 718          
 719          
 720          
 721          /*-----------------------------------------------------------------
 722          函数名称： void add_key(void)
 723          函数功能： 加键
 724          输入参数： 无
 725          返 回 值： 无
 726          -----------------------------------------------------------------*/
 727          void    add_key()
 728          {
 729   1          if(f_disp_yuyue && f_mjs_set)
 730   1          {
 731   2                      /*对预约时间增加*/
 732   2              //f_mjs_set=1;
 733   2              yuyue_add_fun();
 734   2          }
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 13  

 735   1          else
 736   1          {
 737   2                      /*功能1 6调整功率*/
 738   2              if(b_mode==1 || b_mode==6)
 739   2              {
 740   3                              if(f_clock_key)
 741   3                              {
 742   4                                      b_force_flash_cnt=0;    //强制闪烁计数
 743   4                                      f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 744   4                                      b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 745   4                                      key_clr_sec();
 746   4                              }
 747   3                              else
 748   3                              {
 749   4                                      b_force_flash_cnt=0;    //强制闪烁计数
 750   4                                      f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 751   4                                      b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 752   4                                      grade_add_fun();        //档位加功能
 753   4                              }
 754   3                      }
 755   2              else if(b_mode==2 || b_mode==3 ||b_mode==4 || b_mode==5)
 756   2                      {
 757   3                              
 758   3                              if(f_disp_yuyue)
 759   3                              {                       
 760   4                                      f_disp_yuyue=0;
 761   4                                      b_yuyue_run_cnt=0;
 762   4                                      b_force_flash_cnt=0;    //强制闪烁计数
 763   4                                      f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 764   4                                      b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 765   4                                      key_clr_sec();
 766   4                              }
 767   3                              else
 768   3                              {
 769   4                                      if(f_clock_key)
 770   4                                      {
 771   5                                              b_force_flash_cnt=0;    //强制闪烁计数
 772   5                                              f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 773   5                                              b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 774   5                                              key_clr_sec();
 775   5                                      }
 776   4                                      else
 777   4                                      {
 778   5                                              b_force_flash_cnt=0;    //强制闪烁计数
 779   5                                              f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 780   5                                              b_clock_key =0; //运行过程中,无按键按下,1s后锁键        
 781   5                                              dingshi_add_fun();      //定时时间加功能
 782   5                                      }
 783   4                                      
 784   4                              }
 785   3      
 786   3                      }
 787   2                      else if(b_mode==0x80)
 788   2                      {       
 789   3                              /*运行时,加时间*/
 790   3                              if(f_mjs_power)
 791   3                              {
 792   4                                      if(f_clock_key)
 793   4                                      {
 794   5                                              b_force_flash_cnt=0;    //强制闪烁计数
 795   5                                              f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 796   5                                              b_clock_key =0; //运行过程中,无按键按下,1s后锁键
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 14  

 797   5                                              key_clr_sec();
 798   5                                      }
 799   4                                      else
 800   4                                      {
 801   5                                              b_force_flash_cnt=0;    //强制闪烁计数
 802   5                                              f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 803   5                                              b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 804   5                                              baowen_add_fun();       
 805   5                                      }       
 806   4                              }
 807   3                              /*非运行时,加温度*/
 808   3                              else
 809   3                              {
 810   4                                      b_set_wendu+=5;
 811   4                                      if(b_set_wendu>=90)
 812   4                                      {
 813   5                                              b_set_wendu=90;
 814   5                                      }
 815   4      
 816   4      //                              b_set_wendu+=5;
 817   4      //
 818   4      //                              //if(b_set_wendu>100)
 819   4      //                              //      b_set_wendu +=5;
 820   4      //
 821   4      //                              if(b_set_wendu>=225)
 822   4      //                              {
 823   4      //                                      b_set_wendu=150;
 824   4      //                              }
 825   4      //
 826   4      
 827   4      
 828   4      
 829   4      
 830   4                              }
 831   3                      }
 832   2                              
 833   2              //  b_led_slide1=5;
 834   2              
 835   2      
 836   2          }
 837   1      }
 838          
 839          
 840          /*-----------------------------------------------------------------
 841          函数名称： void dec_key(void)
 842          函数功能： 加键
 843          输入参数： 无
 844          返 回 值： 无
 845          -----------------------------------------------------------------*/
 846          void    dec_key()
 847          {
 848   1          if(f_disp_yuyue && f_mjs_set)
 849   1          {
 850   2              //f_mjs_set=1;
 851   2              yuyue_dec_fun();        //预约时间减
 852   2          }
 853   1          else
 854   1          {
 855   2                      /*功能1 6调整功率*/
 856   2              if(b_mode==1 || b_mode==6)
 857   2              {
 858   3                              if(f_clock_key)
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 15  

 859   3                              {
 860   4                                      b_force_flash_cnt=0;    //强制闪烁计数
 861   4                                      f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 862   4                                      b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 863   4                                      key_clr_sec();
 864   4                              }
 865   3                              else
 866   3                              {       
 867   4                                      b_force_flash_cnt=0;    //强制闪烁计数
 868   4                                      f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 869   4                                      b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 870   4                                      grade_dec_fun();        //档位加功能    
 871   4                              }       
 872   3              }
 873   2              else if(b_mode==2 || b_mode==3 || b_mode==4|| b_mode==5)
 874   2                      {       if(f_disp_yuyue)
 875   3                              {                       
 876   4                                      f_disp_yuyue=0;
 877   4                                      b_yuyue_run_cnt=0;
 878   4                                      b_force_flash_cnt=0;    //强制闪烁计数
 879   4                                      f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 880   4                                      b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 881   4                                      key_clr_sec();
 882   4                              }
 883   3                              else
 884   3                              {
 885   4                                      if(f_clock_key)
 886   4                                      {
 887   5                                              b_force_flash_cnt=0;    //强制闪烁计数
 888   5                                              f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 889   5                                              b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 890   5                                              key_clr_sec();
 891   5                                      }
 892   4                                      else
 893   4                                      {
 894   5                                              b_force_flash_cnt=0;    //强制闪烁计数
 895   5                                              f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 896   5                                              b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 897   5                                              dingshi_dec_fun();      //定时时间减功能
 898   5                                      }
 899   4                                      
 900   4                                      
 901   4                              }
 902   3                              
 903   3                      }
 904   2                      else if(b_mode==0x80)
 905   2                      {       
 906   3                              /*运行时,加时间*/
 907   3                              if(f_mjs_power)
 908   3                              {
 909   4                                      if(f_clock_key)
 910   4                                      {
 911   5                                              b_force_flash_cnt=0;    //强制闪烁计数
 912   5                                              f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 913   5                                              b_clock_key =0; //运行过程中,无按键按下,1s后锁键
 914   5                                              key_clr_sec();
 915   5                                      }               
 916   4                                      else
 917   4                                      {
 918   5                                              b_force_flash_cnt=0;    //强制闪烁计数
 919   5                                              f_clock_key     =0;     //1:锁键,0:解锁,可改变时间档位
 920   5                                              b_clock_key =0; //运行过程中,无按键按下,1s后锁键
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 16  

 921   5                                              baowen_dec_fun();
 922   5                                      }               
 923   4                                      
 924   4                              }
 925   3                              /*非运行时,加温度*/
 926   3                              else
 927   3                              {
 928   4                                      b_set_wendu-=5;
 929   4                                      if(b_set_wendu<=40)
 930   4                                      {
 931   5                                              b_set_wendu=40;
 932   5                                      }
 933   4      
 934   4      
 935   4      
 936   4      
 937   4      
 938   4      
 939   4                              }
 940   3                      }
 941   2          }
 942   1      }
 943          
 944          
 945          /*-----------------------------------------------------------------
 946          函数名称： void mode_key(void)
 947          函数功能： 模式键
 948          输入参数： 无
 949          返 回 值： 无
 950          -----------------------------------------------------------------*/
 951          void    mode_key()
 952          {
 953   1      
 954   1              /*如果一开始没有任何状态,则模式功能初始化*/
 955   1              if(!f_mjs_dingshi && !f_mjs_power && !f_mjs_yuyue && !f_mjs_down && !f_mjs_set)
 956   1              {
 957   2                      mode_init();    //功能模式初始化
 958   2                      key_clr_sec();  //刷新显示并且响蜂鸣器
 959   2              }
 960   1              else if (f_mjs_set)
 961   1              {
 962   2                      f_mjs_yuyue=0;
 963   2                      f_mjs_dingshi=1;
 964   2                      f_mjs_set=1;
 965   2                      //f_mjs_power=0;
 966   2      
 967   2              f_disp_dingshi=0;
 968   2              f_disp_yuyue=0;
 969   2              f_dingshi_begin=0;
 970   2      
 971   2      
 972   2                      
 973   2      
 974   2                      b_mode++;
 975   2                      if(b_mode>=7)   //最大功能4
 976   2                              b_mode=1;       //循环
 977   2      
 978   2      
 979   2                      //if (b_mode==3)
 980   2                      //{
 981   2                              f_mjs_dingshi=1;
 982   2                              //f_disp_dingshi=1;
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 17  

 983   2                      //}
 984   2      
 985   2                      /*获取默认时间*/
 986   2              b_dingshi_hour = tab_set[b_mode-1].hour_int;
 987   2              b_dingshi_min  = tab_set[b_mode-1].min_int;
 988   2      
 989   2                      /*获取默认档位*/
 990   2                      b_grade = tab_set[b_mode-1].grade_int;
 991   2                      key_clr_sec();  //刷新显示并且响蜂鸣器
 992   2      
 993   2      
 994   2      
 995   2              }
 996   1      
 997   1      
 998   1      
 999   1      }
1000          
1001          
1002          
1003          
1004          /*-----------------------------------------------------------------
1005          函数名称： void key_clr_sec(void)
1006          函数功能： 刷新显示并且响蜂鸣器
1007          输入参数： 无
1008          返 回 值： 无
1009          -----------------------------------------------------------------*/
1010          void    key_clr_sec()
1011          {
1012   1          b_key_double=0;
1013   1          b_led_slide1=0;
1014   1          b_mjs_set_sec=0;
1015   1          gb_flashTime=0;
1016   1          gf_flash=1;
1017   1          gb_1s=0;
1018   1          if(b_key_longcnt==0)
1019   1              open_buz(1);    //按键音
1020   1                      //open_buz(2);  //报警音
1021   1                      //open_buz(3);  //开机音
1022   1                      //open_buz(4);  //工作开始音
1023   1                      //open_buz(5);  //工作完成音
1024   1      }
1025          
1026          
1027          
1028          
1029          /*-----------------------------------------------------------------
1030          函数名称： void key_deal(void)
1031          函数功能： 按键动作,20MS执行一次
1032          输入参数： 无
1033          返 回 值： 无
1034          -----------------------------------------------------------------*/
1035          void    key_deal()
1036          {
1037   1          key_scan();
1038   1      
1039   1          b_key_double++;   //双击计时变量
1040   1          if(b_key_double >= 50)
1041   1          {
1042   2              //      退出双击时间
1043   2              f_key_double = 0;
1044   2              b_key_double = 0;
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 18  

1045   2          }
1046   1      
1047   1          if(f_key_done==1)
1048   1          {
1049   2              f_key_done=0;
1050   2              if(!b_warning)
1051   2              {
1052   3                      if(f_test)
1053   3                      {
1054   4                        open_buz(1);
1055   4                      }
1056   3                      else
1057   3                      {
1058   4                  /*-----------------------------此处按键处理----------------------------*/
1059   4                  switch(b_key_value)
1060   4                  {
1061   5                  case c_k1:  //预约/保温
1062   5                  {   
1063   6                                      /*在待机状态下,按下,进入手动保温*/
1064   6                                      if(!f_mjs_set&& !f_mjs_power && !f_mjs_yuyue && !b_mode)
1065   6                                      {
1066   7                                              key_clr_sec();  //刷新显示并且响蜂鸣器
1067   7                                              baowen_fun();   //保温功能
1068   7                                      }
1069   6                                      /*设置状态下,模式2,3,4可进入*/
1070   6                                      else if(f_mjs_set )
1071   6                                      {
1072   7                                              if ((b_mode==2) || (b_mode == 3) ||(b_mode == 4))
1073   7                                              {
1074   8                                              key_yuyue();
1075   8                                              key_clr_sec();
1076   8                                              }
1077   7                                      }
1078   6      
1079   6                      break;
1080   6      
1081   6                  }
1082   5                  case c_k2:  //功能/取消
1083   5                  {
1084   6                                      /*运行了按下->关机*/
1085   6                                      if (f_mjs_power)
1086   6                                      {       
1087   7                                              /*短按*/
1088   7                                              if(b_key_longcnt==0)
1089   7                                              {
1090   8                                                      quit_work();    //退出工作
1091   8                                                      key_clr_sec();  //刷新显示并且响蜂鸣器
1092   8                                                      open_buz(1);    //按键音
1093   8                                              }
1094   7                                      }
1095   6                                      /*预约倒计时按下->关机*/
1096   6                                      else if (f_mjs_yuyue && !f_mjs_set)
1097   6                                      {       
1098   7                                              /*短按*/
1099   7                                              if(b_key_longcnt==0)
1100   7                                              {
1101   8                                                      quit_work();    //退出工作
1102   8                                                      key_clr_sec();  //刷新显示并且响蜂鸣器
1103   8                                              }
1104   7      
1105   7                                      }
1106   6                                      else
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 19  

1107   6                                      {                                               /*短按*/
1108   7                                              if(b_key_longcnt==0)
1109   7                                              {
1110   8                                                      mode_key();     
1111   8                                              }
1112   7                                      }
1113   6      
1114   6      
1115   6                                      f_readKey_over=0;
1116   6                                      if(b_key_longcnt<50)
1117   6                                      {
1118   7                                              b_key_longcnt++;
1119   7                                      }
1120   6      
1121   6      
1122   6      
1123   6                      break;                          
1124   6                              }
1125   5      
1126   5      
1127   5                  case c_k3:  //减
1128   5                  {
1129   6                      if(b_warning)
1130   6                          break;
1131   6                      //有功能才按得动   
1132   6                      if(b_mode==0)
1133   6                          break;  
1134   6      
1135   6                                      ////保温功能按不动
1136   6                                      //if(b_mode&0x80)
1137   6                                      //      break;
1138   6      
1139   6                                      ////功能3(煮饭)按不动
1140   6                                      //if(b_mode==3)
1141   6                                      //      break;
1142   6                                      
1143   6                                      ////运行后,除了功能2(煎炒)都按不动
1144   6                                      //if(f_mjs_power && (b_mode!=2))
1145   6                                      //      break;
1146   6      
1147   6      
1148   6                      //key_clr_sec();        //刷新显示并且响蜂鸣器
1149   6      
1150   6                                      //短按跟长按连续响应
1151   6                                      if((b_key_longcnt==0)||(b_key_longcnt>=50))
1152   6                                      {
1153   7                                              key_clr_sec();  
1154   7                                              dec_key();
1155   7                                      }
1156   6                                      f_readKey_over=0;
1157   6                                      b_key_longcnt++;
1158   6                                      if(b_key_longcnt>50)
1159   6                                      {
1160   7                                              b_key_longcnt=45;
1161   7                                      }
1162   6                      break;
1163   6                  }
1164   5                  case c_k4:  //加
1165   5                  {
1166   6                                      //报错了,按不动
1167   6                      if(b_warning)
1168   6                          break;
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 20  

1169   6      
1170   6                      //有功能才按得动   
1171   6                      if(b_mode==0)
1172   6                          break;  
1173   6      
1174   6                                      ////保温功能按不动
1175   6                                      //if(b_mode&0x80)
1176   6                                      //      break;
1177   6      
1178   6                                      ////功能3(煮饭)按不动
1179   6                                      //if(b_mode==3)
1180   6                                      //      break;
1181   6      
1182   6                                      ////运行后,除了功能2(煎炒)都按不动
1183   6                                      //if(f_mjs_power && (b_mode!=2))
1184   6                                      //      break;
1185   6      
1186   6                                      
1187   6                      //key_clr_sec();        //刷新显示并且响蜂鸣器
1188   6      
1189   6                                      //短按跟长按
1190   6                                      if((b_key_longcnt==0)||(b_key_longcnt>=50))
1191   6                                      {
1192   7                                              key_clr_sec();  
1193   7                                              add_key();
1194   7                                      }
1195   6                                      f_readKey_over=0;
1196   6                                      b_key_longcnt++;
1197   6                                      if(b_key_longcnt>50)
1198   6                                      {
1199   7                                              b_key_longcnt=45;
1200   7                                      }
1201   6                      break;
1202   6                  }    
1203   5      
1204   5      
1205   5      
1206   5                              
1207   5                  default:
1208   5                      break;
1209   5                  }
1210   4                }
1211   3                  /*--------------------------------------------------------------------*/
1212   3              }
1213   2              else
1214   2              {
1215   3                  //清除报警
1216   3                              if(b_key_value == c_k2)
1217   3                              {
1218   4                                      key_clr_sec();
1219   4                                      quit_work();
1220   4                                      b_warning=0;
1221   4                              }
1222   3              }
1223   2      
1224   2          }
1225   1      }
1226          
1227          #if     0
              //              常用按键处理程序，使用时直接将其复制到按键处理函数中，并根据实际情况相应修改
              //                              加键
              if(f_disp_yuyue||(f_disp_dingshi&&(b_mode!=1)))
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 21  

              {
                  if((b_key_longcnt==0)||(b_key_longcnt>=50))
                  {
                      key_clr_sec();
                      add_key();
                  }
                  f_readKey_over=0;
                  b_key_longcnt++;
                  if(b_key_longcnt>50)
                  {
                      b_key_longcnt=40;
                  }
              }
              
              
              //              减键
              if(f_disp_yuyue||(f_disp_dingshi&&(b_mode!=1)))
              {
                  if((b_key_longcnt==0)||(b_key_longcnt>=50))
                  {
                      key_clr_sec();
                      dec_key();
                  }
                  f_readKey_over=0;
                  b_key_longcnt++;
                  if(b_key_longcnt>50)
                  {
                      b_key_longcnt=40;
                  }
              }
              
              //              模式键：直接生效
              if(!f_mjs_power&&(!(!f_mjs_set&&f_mjs_yuyue)))
              {
                  key_clr_sec();
                  mode_key();
                  action_work();
              }
              
              //              模式键：模式+1
              if(!f_mjs_power&&(!(!f_mjs_set&&f_mjs_yuyue)))
              {
                  key_clr_sec();
                  mode_key();
              }
              
              //              保温/取消键
              key_clr_sec();
              if(!f_mjs_power&&(!(!f_mjs_set&&f_mjs_yuyue))&&(!f_mjs_set))
              {
                  quit_work();
                  baowen_yuyu_key();
              }
              else
                  quit_work();
              
              //              开始键
              if(!f_mjs_power&&(!(!f_mjs_set&&f_mjs_yuyue)))
              {
                  if(b_mode)
                      action_work();
                  else
C51 COMPILER V9.60.0.0   KEY                                                               05/09/2023 16:49:07 PAGE 22  

                  {
                      mode_key();
                      action_work();
                  }
              }
              
              //              预约键
              if(((!f_mjs_set)&&(!f_mjs_yuyue)&&(!f_mjs_power)) || f_mjs_set)         //
              {
                  key_yuyue();
                  key_clr_sec();
              }
              
              
              //              取消键
              if(f_mjs_power || f_mjs_set || f_mjs_yuyue)
              {
                  key_clr_sec();
                  quit_work();
              }
              
              #endif
1315          
1316          
1317          
1318          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2175    ----
   CONSTANT SIZE    =     66    ----
   XDATA SIZE       =     21    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      9    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
